'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FETCH = exports.EQUAL = exports.USE_CURRENT = exports.USE_INCOMING = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _difference = require('lodash/difference');

var _difference2 = _interopRequireDefault(_difference);

var _last = require('lodash/last');

var _last2 = _interopRequireDefault(_last);

var _first = require('lodash/first');

var _first2 = _interopRequireDefault(_first);

var _memoize = require('lodash/memoize');

var _memoize2 = _interopRequireDefault(_memoize);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _sparkCore = require('@ciscospark/spark-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var USE_INCOMING = exports.USE_INCOMING = 'USE_INCOMING'; /**!
                                                           *
                                                           * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
                                                           */

var USE_CURRENT = exports.USE_CURRENT = 'USE_CURRENT';
var EQUAL = exports.EQUAL = 'EQUAL';
var FETCH = exports.FETCH = 'FETCH';

var Locus = _sparkCore.SparkPlugin.extend({
  namespace: 'Locus',

  /**
   * Alert the specified locus that the local user has been notified of the
   * locus's active state
   * @param {Types~Locus} locus
   * @returns {Promise}
   */
  alert: function alert(locus) {
    return this.request({
      method: 'PUT',
      uri: locus.url + '/participant/alert',
      body: {
        deviceUrl: this.spark.device.url
      }
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Calls the specified invitee and offers the specified media via
   * options.localSdp
   * @param {string} invitee
   * @param {Object} options
   * @param {Object} options.localSdp
   * @returns {Promise<Types~Locus>}
   */
  create: function create(invitee, options) {
    options = options || {};

    return this.request({
      method: 'POST',
      service: 'locus',
      resource: 'loci/call',
      body: {
        deviceUrl: this.spark.device.url,
        invitee: {
          invitee: invitee
        },
        localMedias: [{
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: options.localSdp
          })
        }]
      }
    })
    // res.body.mediaConnections is deprecated so just return the locus
    .then(function (res) {
      return res.body.locus;
    });
  },


  /**
   * Lists active loci
   * @returns {Promise<Array<Types~Locus>>}
   */
  list: function list() {
    return this.request({
      method: 'GET',
      service: 'locus',
      resource: 'loci'
    }).then(function (res) {
      return res.body.loci;
    });
  },


  /**
   * Retrieves a single Locus
   * @param {Types~Locus} locus
   * @returns {Types~Locus}
   */
  get: function get(locus) {
    return this.request({
      method: 'GET',
      uri: '' + locus.url
    }).then(function (res) {
      return res.body;
    });
  },


  /**
   * Join the specified Locus and offer to send it media
   * @param {Types~Locus} locus
   * @param {Object} options
   * @param {Object} options.localSdp
   * @returns {Types~Locus}
   */
  join: function join(locus, options) {
    options = options || {};

    // TODO should options.localSdp be an array?
    return this.request({
      method: 'POST',
      uri: locus.url + '/participant',
      body: {
        deviceUrl: this.spark.device.url,
        localMedias: [{
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: options.localSdp
          })
        }]
      }
    })
    // The mediaConnections object is deprecated, so just return the locus
    .then(function (res) {
      return res.body.locus;
    });
  },


  /**
   * Leave the specified Locus
   * @param {Types~Locus} locus
   * @returns {Promise<Types~Locus>}
   */
  leave: function leave(locus) {
    var _this = this;

    return this.request({
      method: 'PUT',
      uri: locus.self.url + '/leave',
      body: {
        deviceUrl: this.spark.device.url
      }
    }).then(function (res) {
      return res.body.locus;
    }).catch(function (reason) {
      if (reason instanceof _sparkCore.SparkHttpError.Conflict) {
        return _this.get(locus);
      }
      return _promise2.default.reject(reason);
    });
  },


  /**
   * Decline to join the specified Locus
   * @param {Types~Locus} locus
   * @returns {Promise<Types~Locus>}
   */
  decline: function decline(locus) {
    var _this2 = this;

    return this.request({
      method: 'PUT',
      // TODO can this be locus.self.url? or does self only work once we've
      // joined?
      uri: locus.url + '/participant/decline',
      body: {
        deviceUrl: this.spark.device.url
      }
    }).then(function (res) {
      return res.body;
    }).catch(function (reason) {
      if (reason instanceof _sparkCore.SparkHttpError.Conflict) {
        return _this2.get(locus);
      }
      return _promise2.default.reject(reason);
    });
  },


  /**
   * Send a new sdp to Linus via the Locus API to update media state (e.g. to
   * start or stop sending audio or video)
   * @param {Types~Locus} locus
   * @param {Object} options
   * @param {Object} options.localSdp
   * @param {Object} options.mediaId
   * @returns {Promise<Types~Locus>}
   */
  updateMedia: function updateMedia(locus, options) {
    return this.request({
      method: 'PUT',
      uri: locus.self.url + '/media',
      body: {
        deviceUrl: this.spark.device.url,
        localMedias: [{
          type: 'SDP',
          localSdp: (0, _stringify2.default)({
            type: 'SDP',
            sdp: options.localSdp
          }),
          mediaId: options.mediaId
        }]
      }
    }).then(function (res) {
      return res.body.locus;
    });
  },


  /**
   * Compares two loci to determine which one contains the most recent state
   * @param {Types~Locus} current
   * @param {Types~Locus} incoming
   * @returns {string} one of USE_INCOMING, USE_CURRENT, EQUAL, or FETCH
   */
  compare: function compare(current, incoming) {
    if (!current) {
      throw new Error('`current` is required');
    }

    if (!incoming) {
      throw new Error('`incoming` is required');
    }
    // complexity here is unavoidable
    /* eslint complexity: [0] */
    /* eslint max-statements: [0] */

    // must pick one of arrow-body-style or no-confusing-arrow to disable
    /* eslint arrow-body-style: [0] */

    // after running the #compare() test suite in a loop, there doesn't seem to
    // be any appreciable difference when used with or without memoize; since
    // real locus sequences are likely to contain more sequence numbers than
    // those in the test suite, I have to assume memoize can only help and the
    // overhead of memoizing these methods is not a problem.

    var getEntriesFirstValue = (0, _memoize2.default)(function (locus) {
      return locus.sequence.entries.length === 0 ? 0 : (0, _first2.default)(locus.sequence.entries);
    });
    var getEntriesLastValue = (0, _memoize2.default)(function (locus) {
      return locus.sequence.entries.length === 0 ? 0 : (0, _last2.default)(locus.sequence.entries);
    });
    var getCompareFirstValue = (0, _memoize2.default)(function (locus) {
      return locus.sequence.rangeStart || getEntriesFirstValue(locus);
    });
    var getCompareLastValue = (0, _memoize2.default)(function (locus) {
      return getEntriesLastValue(locus) || locus.sequence.rangeEnd;
    });
    /**
     * @param {number} entry
     * @param {Types~Locus} locus
     * @private
     * @returns {Boolean}
     */
    function inRange(entry, locus) {
      return entry >= locus.sequence.rangeStart && entry <= locus.sequence.rangeEnd;
    }

    if (getCompareLastValue(current) < getCompareFirstValue(incoming)) {
      return USE_INCOMING;
    }

    if (getCompareFirstValue(current) > getCompareLastValue(incoming)) {
      return USE_CURRENT;
    }

    var currentOnlyEntries = (0, _difference2.default)(current.sequence.entries, incoming.sequence.entries);
    var incomingOnlyEntries = (0, _difference2.default)(incoming.sequence.entries, current.sequence.entries);
    var currentOnly = [];
    var incomingOnly = [];

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(currentOnlyEntries), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var i = _step.value;

        if (!inRange(i, incoming)) {
          currentOnly.push(i);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = (0, _getIterator3.default)(incomingOnlyEntries), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _i = _step2.value;

        if (!inRange(_i, current)) {
          incomingOnly.push(_i);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    if (!currentOnly.length && !incomingOnly.length) {
      if (current.sequence.rangeEnd > incoming.sequence.rangeEnd) {
        return USE_CURRENT;
      }
      if (current.sequence.rangeEnd < incoming.sequence.rangeEnd) {
        return USE_INCOMING;
      }
      if (current.sequence.rangeStart < incoming.sequence.rangeStart) {
        return USE_CURRENT;
      }
      if (current.sequence.rangeStart > incoming.sequence.rangeStart) {
        return USE_INCOMING;
      }
      return EQUAL;
    }

    if (currentOnly.length && !incomingOnly.length) {
      return USE_CURRENT;
    }

    if (!currentOnly.length && incomingOnly.length) {
      return USE_INCOMING;
    }

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = (0, _getIterator3.default)(currentOnly), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _i2 = _step3.value;

        if (getCompareFirstValue(incoming) < _i2 && _i2 < getCompareLastValue(incoming)) {
          return FETCH;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = (0, _getIterator3.default)(incomingOnly), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var _i3 = _step4.value;

        if (getCompareFirstValue(current) < _i3 && _i3 < getCompareLastValue(current)) {
          return FETCH;
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return) {
          _iterator4.return();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    if (currentOnly[0] > incomingOnly[0]) {
      return USE_CURRENT;
    }

    return USE_INCOMING;
  },
  getCallHistory: function getCallHistory(options) {
    options = options || {};
    var from = new Date(options.from || Date.now()).toISOString();

    return this.request({
      method: 'GET',
      service: 'janus',
      resource: 'history/userSessions',
      qs: { from: from }
    }).then(function (res) {
      return res.body;
    });
  }
});

exports.default = Locus;
//# sourceMappingURL=locus.js.map
