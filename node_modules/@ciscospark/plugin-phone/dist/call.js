'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _desc, _value, _obj; /**!
                          *
                          * Copyright (c) 2016 Cisco Systems, Inc. See LICENSE file.
                          * @private
                          */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

var _sparkCore = require('@ciscospark/spark-core');

var _common = require('@ciscospark/common');

var _webrtc = require('./webrtc');

var _pluginLocus = require('@ciscospark/plugin-locus');

var _stateParsers = require('./state-parsers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * @event ringing
 * @instance
 * @memberof Call
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} Types~Feedback
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 * @extends SparkPlugin
 */
var Call = _sparkCore.SparkPlugin.extend((_obj = {
  namespace: 'Phone',

  session: {
    locus: 'object',
    pc: 'object',
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    localMediaStream: 'object',
    // TODO determine if stream URLs can be deprecated; it looks like the video
    // tag may accept streams directly these days.
    /**
     * Object URL that refers to {@link Call#localMediaStream}. Will be
     * automatically deallocated when the call ends
     * @instance
     * @memberof Call
     * @member {string}
     */
    localMediaStreamUrl: 'string',
    /**
     * Access to the remote party’s `MediaStream`. `null` before connected.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: 'object',
    /**
     * Object URL that refers to {@link Call#remoteMediaStream}. Will be
     * automatically deallocated when the call ends
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    remoteMediaStreamUrl: 'string',
    /**
     * Indicates if the client is sending audio
     * @instance
     * @memberof Call
     * @member {Boolean}
     * @readonly
     */
    sendingAudio: 'boolean',
    /**
     * Indicates if the client is sending video
     * @instance
     * @memberof Call
     * @member {Boolean}
     * @readonly
     */
    sendingVideo: 'boolean',
    /**
     * Indicates if the client is receiving audio
     * @instance
     * @memberof Call
     * @member {Boolean}
     * @readonly
     */
    receivingAudio: 'boolean',
    /**
     * Indicates if the client is receiving video
     * @instance
     * @memberof Call
     * @member {Boolean}
     * @readonly
     */
    receivingVideo: 'boolean',

    wasSendingAudio: 'boolean',
    wasSendingVideo: 'boolean',
    wasReceivingAudio: 'boolean',
    wasReceivingVideo: 'boolean'
  },

  // FIXME in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change
  derived: {
    isActive: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.isActive)(this.locus);
      }
    },
    activeParticipants: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _stateParsers.activeParticipants)(this.locus);
      }
    },
    activeParticipantsCount: {
      deps: ['activeParticipants'],
      fn: function fn() {
        return this.activeParticipants.length;
      }
    },
    joined: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joined)(this.locus);
      }
    },
    joinedOnThisDevice: {
      deps: ['locus'],
      default: false,
      fn: function fn() {
        return this.locus && (0, _stateParsers.joinedOnThisDevice)(this.spark, this.locus);
      }
    },
    locusUrl: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus.url;
      }
    },
    device: {
      deps: ['locus'],
      fn: function fn() {
        var _this = this;

        return this.locus.self && (0, _find2.default)(this.locus.self.devices, function (item) {
          return item.url === _this.spark.device.url;
        });
      }
    },
    mediaConnection: {
      deps: ['device'],
      fn: function fn() {
        return this.device && this.device.mediaConnections[0];
      }
    },
    mediaId: {
      deps: ['mediaConnection'],
      fn: function fn() {
        return this.mediaConnection && this.mediaConnection.mediaId;
      }
    },
    remoteAudioMuted: {
      deps: ['remote'],
      fn: function fn() {
        return (0, _stateParsers.remoteAudioMuted)(this.remote);
      }
    },
    remoteVideoMuted: {
      deps: ['remote'],
      fn: function fn() {
        return (0, _stateParsers.remoteVideoMuted)(this.remote);
      }
    },
    direction: {
      deps: ['locus'],
      fn: function fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return 'out';
        }
        return (0, _stateParsers.direction)(this.locus);
      }
    },
    from: {
      deps: ['direction', 'local', 'remote'],
      fn: function fn() {
        return this.direction === 'out' ? this.local : this.remote;
      }
    },
    to: {
      deps: ['direction', 'local', 'remote'],
      fn: function fn() {
        return this.direction === 'in' ? this.local : this.remote;
      }
    },
    local: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && this.locus.self;
      }
    },
    remote: {
      deps: ['locus'],
      fn: function fn() {
        return this.locus && (0, _stateParsers.remoteParticipant)(this.locus);
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: ['joinedOnThisDevice', 'local', 'remote'],
      fn: function fn() {
        if (this.joinedOnThisDevice && this.remote && (0, _stateParsers.participantIsJoined)(this.remote)) {
          return 'connected';
        }

        if (this.remote && this.local) {
          if (this.remote.state === 'LEFT' || this.local.state === 'LEFT') {
            return 'disconnected';
          }

          if (this.remote.state === 'DECLINED') {
            return 'disconnected';
          }

          if (this.remote.state === 'NOTIFIED') {
            return 'ringing';
          }
        }

        return 'initiated';
      }
    },
    localAudioDirection: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _webrtc.mediaDirection)('audio', this.pc).toLowerCase();
      }
    },
    localVideoDirection: {
      deps: ['locus'],
      fn: function fn() {
        return (0, _webrtc.mediaDirection)('video', this.pc).toLowerCase();
      }
    },
    remoteAudioDirection: {
      deps: ['locus'],
      fn: function fn() {
        // Until Locus fixes the bug that prevents do both renegotiation and
        // state update, we can't trust the remote direction from the locus
        return 'unknown';
      }
    },
    remoteVideoDirection: {
      deps: ['locus'],
      fn: function fn() {
        // Until Locus fixes the bug that prevents do both renegotiation and
        // state update, we can't trust the remote direction from the locus
        return 'unknown';
      }
    }
  },

  /**
   * Initializer
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    // We can't trust the mercury event name, so we need to pipe all locus
    // events through the same handler.
    // TODO adjust plugin-mercury to emit events by namespace so we can listen
    // for incoming locus events in a single handler.
    _pluginLocus.eventKeys.forEach(function (key) {
      _this2.listenTo(_this2.spark.mercury, 'event:' + key, function (event) {
        return _this2._onLocusEvent(event);
      });
    });

    this.on('disconnected', function () {
      _this2.stopListening(_this2.spark.mercury);
      _this2.off();
      URL.revokeObjectURL(_this2.localMediaStreamUrl);
      URL.revokeObjectURL(_this2.remoteMediaStreamUrl);
    });

    this.pc = new RTCPeerConnection({ iceServers: [] });
    // TODO given all the other chrome/ff discrepancies, make sure this works in
    // both browsers
    this.pc.ontrack = function (event) {
      _this2.remoteMediaStream = event.streams[0];
    };

    this.on('change:remoteMediaStream', function () {
      if (_this2.remoteMediaStreamUrl) {
        URL.revokeObjectURL(_this2.remoteMediaStreamUrl);
      }
      _this2.remoteMediaStreamUrl = URL.createObjectURL(_this2.remoteMediaStream);
    });

    this.on('change:remoteMediaStreamUrl', function () {
      _this2.trigger('remoteMediaStream:change');
    });

    this.on('change:localMediaStreamUrl', function () {
      _this2.trigger('localMediaStream:change');
    });

    this.on('change:remoteAudioMuted', function () {
      _this2.trigger('remoteAudioMuted:change');
    });

    this.on('change:remoteVideoMuted', function () {
      _this2.trigger('remoteVideoMuted:change');
    });

    this.on('change:isActive', function () {
      if (!_this2.isActive) {
        if (_this2.joinedOnThisDevice) {
          _this2.logger.info('call: hanging up due to locus going inactive');
          _this2.hangup();
        }
      }
    });

    this.on('change:activeParticipantsCount', function () {
      var previousLocus = _this2.previousAttributes().locus;
      // TODO this logic probably goes in state-parsers
      if (_this2.joinedOnThisDevice && _this2.activeParticipantsCount === 1 && previousLocus && (0, _stateParsers.activeParticipants)(previousLocus).length > 1) {
        _this2.logger.info('call: hanging up due to last participant in call');
        _this2.hangup();
      }
    });

    this.on('change:status', function () {
      switch (_this2.status) {
        case 'ringing':
          _this2.trigger('ringing');
          break;
        case 'connected':
          _this2.trigger('connected');
          break;
        case 'disconnected':
          _this2.trigger('disconnected');
          break;
        default:
        // do nothing
      }
    });
  },


  /**
   * Answers an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a noop
   * @instance
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer: function answer(options) {
    var _this3 = this;

    // TODO make this a noop for outbound calls
    this.logger.info('call: answering');
    // Locus may *think* we're connected if we e.g. reload the page mid-call. If
    // the user decides to answer the in-progress call that locus thinks they're
    // a part of, we should immediately emit the connected event.
    if (this.joinedOnThisDevice) {
      this.logger.info('call: already joined on this device');
    }
    return this._join('join', this.locus, options).then((0, _common.tap)(function () {
      return _this3.logger.info('call: answered');
    }));
  },


  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge: function acknowledge() {
    var _this4 = this;

    this.logger.info('call: acknowledging');
    // TODO call this method automatically unless config says otherwise
    return this.spark.locus.alert(this.locus).then(function (locus) {
      return _this4._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this4.logger.info('call: acknowledged');
    }));
  },


  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial: function dial(invitee, options) {
    var _this5 = this;

    this.logger.info('call: dialing');
    this._join('create', invitee, options).then((0, _common.tap)(function () {
      return _this5.logger.info('call: dialed');
    })).catch(function (reason) {
      _this5.trigger('error', reason);
    });

    return this;
  },


  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup: function hangup() {
    var _this6 = this;

    // TODO For example, hangup may be invoked immediately after invoking dial()
    // but before the “locus” has been created. In this case  invoking  hangup()
    // should short circuit the call setup process and take whatever action is
    // necessary to ensure all parties are notified that the call is
    // disconnected.
    // TODO For incoming calls, invoking hangup should be synonymous with
    // invoking reject()
    this.logger.info('call: hanging up');

    (0, _webrtc.end)(this.pc);

    if (!this.locus) {
      this.logger.info('call: no locus, waiting for rest call to complete before hanging up');
      return this.when('change:locus').then(function () {
        return _this6.hangup();
      });
    }

    return this._hangup();
  },
  _hangup: function _hangup() {
    var _this7 = this;

    return this.spark.locus.leave(this.locus).then(function (locus) {
      return _this7._setLocus(locus);
    })
    // TODO update sending and receving based on the peer connection's streams
    .then(function () {
      return _this7.set({
        sendingAudio: false,
        sendingVideo: false,
        receivingAudio: false,
        receivingVideo: false
      });
    }).then((0, _common.tap)(function () {
      return _this7.stopListening(_this7.spark.mercury);
    })).then((0, _common.tap)(function () {
      return _this7.off();
    })).then((0, _common.tap)(function () {
      return _this7.logger.info('call: hung up');
    }));
  },


  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline: function decline() {
    return this.reject();
  },
  reject: function reject() {
    var _this8 = this;

    // TODO should be a noop for outgoing calls
    this.logger.info('call: rejecting');
    /* eslint no-invalid-this: [0] */
    return this.spark.locus.decline(this.locus).then(function (locus) {
      return _this8._setLocus(locus);
    }).then((0, _common.tap)(function () {
      return _this8.stopListening(_this8.spark.mercury);
    })).then((0, _common.tap)(function () {
      return _this8.off();
    })).then((0, _common.tap)(function () {
      return _this8.logger.info('call: rejected');
    }));
  },


  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio: function startSendingAudio() {
    return this._changeMedia({ sendingAudio: true });
  },


  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo: function startSendingVideo() {
    return this._changeMedia({ sendingVideo: true });
  },
  startReceivingAudio: function startReceivingAudio() {
    return this._changeMedia({ receivingAudio: true });
  },
  startReceivingVideo: function startReceivingVideo() {
    return this._changeMedia({ receivingVideo: true });
  },


  /**
   * Toggles receiving audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio: function toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },


  /**
   * Toggles receiving video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo: function toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },
  stopReceivingAudio: function stopReceivingAudio() {
    return this._changeMedia({ receivingAudio: false });
  },
  stopReceivingVideo: function stopReceivingVideo() {
    return this._changeMedia({ receivingVideo: false });
  },


  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio: function toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },


  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo: function toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },


  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {Types~Feedback} feedback
   * @returns {Promise}
   */
  sendFeedback: function sendFeedback(feedback) {
    return this.spark.metrics.submit('meetup_call_user_rating', feedback);
  },


  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio: function stopSendingAudio() {
    return this._changeMedia({ sendingAudio: false });
  },


  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo: function stopSendingVideo() {
    return this._changeMedia({ sendingVideo: false });
  },
  _changeMedia: function _changeMedia(constraints) {
    var _this9 = this;

    return new _promise2.default(function (resolve) {
      /* eslint complexity: [0] */
      if (!_this9.pc) {
        resolve();
        return;
      }

      constraints = (0, _defaults2.default)({}, constraints, {
        sendingVideo: _this9.sendingVideo,
        sendingAudio: _this9.sendingAudio,
        receivingVideo: _this9.receivingVideo,
        receivingAudio: _this9.receivingAudio
      });

      constraints = (0, _assign2.default)({}, constraints, {
        wasSendingAudio: _this9.sendingAudio,
        wasSendingVideo: _this9.sendingVideo,
        wasReceivingAudio: _this9.receivingAudio,
        wasReceivingVideo: _this9.receivingVideo
      });

      _this9.set(constraints);

      var promises = [];
      if (constraints.sendingAudio && !constraints.wasSendingAudio) {
        promises.push((0, _webrtc.startSendingAudio)(_this9.pc));
      }

      if (!constraints.sendingAudio && constraints.wasSendingAudio) {
        promises.push((0, _webrtc.stopSendingAudio)(_this9.pc));
      }

      if (constraints.sendingVideo && !constraints.wasSendingVideo) {
        promises.push((0, _webrtc.startSendingVideo)(_this9.pc));
      }

      if (!constraints.sendingVideo && constraints.wasSendingVideo) {
        promises.push((0, _webrtc.stopSendingVideo)(_this9.pc));
      }

      if (constraints.receivingAudio && !constraints.wasReceivingAudio) {
        promises.push((0, _webrtc.startReceivingAudio)(_this9.pc));
      }

      if (!constraints.receivingAudio && constraints.wasReceivingAudio) {
        promises.push((0, _webrtc.stopReceivingAudio)(_this9.pc));
      }

      if (constraints.receivingVideo && !constraints.wasReceivingVideo) {
        promises.push((0, _webrtc.startReceivingVideo)(_this9.pc));
      }

      if (!constraints.receivingVideo && constraints.wasReceivingVideo) {
        promises.push((0, _webrtc.stopReceivingVideo)(_this9.pc));
      }

      resolve(_promise2.default.all(promises).then(function () {
        return _this9._updateMedia();
      }).then(function () {
        return _this9.unset(['wasSendingAudio', 'wasSendingVideo', 'wasReceivingAudio', 'wasReceivingVideo']);
      }));
    });
  },
  _join: function _join(locusMethodName, target, options) {
    var _this10 = this;

    options = options || {};
    options.constraints = (0, _defaults2.default)(options.constraints, {
      audio: true,
      video: true
    });
    var recvOnly = !options.constraints.audio && !options.constraints.video;
    options.offerOptions = (0, _defaults2.default)(options.offerOptions, {
      offerToReceiveAudio: recvOnly || options.constraints.audio,
      offerToReceiveVideo: recvOnly || options.constraints.video
    });

    var promise = void 0;
    if (!recvOnly) {
      promise = _promise2.default.resolve(options.localMediaStream || this.spark.phone.createLocalMediaStream(options)).then(function (localMediaStream) {
        _this10.localMediaStream = localMediaStream;
        _this10.localMediaStreamUrl = URL.createObjectURL(localMediaStream);
        (0, _webrtc.addStream)(_this10.pc, localMediaStream);
      });
    }

    return _promise2.default.resolve(promise).then(function () {
      return (0, _webrtc.createOffer)(_this10.pc, options.offerOptions);
    }).then(function (offer) {
      return _this10.spark.locus[locusMethodName](target, {
        localSdp: offer
      });
    }).then(function (locus) {
      _this10._setLocus(locus);
      var answer = JSON.parse(_this10.mediaConnection.remoteSdp).sdp;
      return (0, _webrtc.acceptAnswer)(_this10.pc, answer);
    }).then(function () {
      _this10.set({
        sendingAudio: options.constraints.audio,
        sendingVideo: options.constraints.video,
        receivingAudio: options.offerOptions.offerToReceiveAudio,
        receivingVideo: options.offerOptions.offerToReceiveVideo
      });
    });
  },
  _onLocusEvent: function _onLocusEvent(event) {
    if (this.locus && event.data.locus.url === this.locus.url) {
      this.logger.info('locus event: ' + event.data.eventType);
      this._setLocus(event.data.locus);
    }
  },
  _setLocus: function _setLocus(incoming) {
    var _this11 = this;

    var current = this.locus;
    if (!current) {
      this.locus = incoming;
      return _promise2.default.resolve();
    }
    var action = this.spark.locus.compare(current, incoming);

    switch (action) {
      case _pluginLocus.USE_INCOMING:
        this.locus = incoming;
        break;
      case _pluginLocus.FETCH:
        return this.spark.locus.get(current).then(function (locus) {
          return _this11._setLocus(locus);
        });
      default:
      // do nothing
    }

    return _promise2.default.resolve();
  },
  _updateMedia: function _updateMedia() {
    var _this12 = this;

    /* eslint max-nested-callbacks: [0] */
    return new _promise2.default(function (resolve) {
      process.nextTick(function () {
        resolve((0, _webrtc.createOffer)(_this12.pc, {
          offerToReceiveAudio: _this12.receivingAudio,
          offerToReceiveVideo: _this12.receivingVideo
        }).then(function (offer) {
          return _this12.spark.locus.updateMedia(_this12.locus, {
            localSdp: offer,
            mediaId: _this12.mediaId,
            audioMuted: !_this12.sendingAudio,
            videoMuted: !_this12.sendingVideo
          });
        }).then(function (locus) {
          _this12._setLocus(locus);
          var sdp = JSON.parse(_this12.mediaConnection.remoteSdp).sdp;
          return (0, _webrtc.acceptAnswer)(_this12.pc, sdp);
        }));
      });
    });
  }
}, (_applyDecoratedDescriptor(_obj, '_hangup', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_hangup'), _obj), _applyDecoratedDescriptor(_obj, 'reject', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'reject'), _obj), _applyDecoratedDescriptor(_obj, '_updateMedia', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_updateMedia'), _obj)), _obj));

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

exports.default = Call;
//# sourceMappingURL=call.js.map
