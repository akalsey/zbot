'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _sparkCore = require('@ciscospark/spark-core');

var _pluginLocus = require('@ciscospark/plugin-locus');

var _call = require('./call');

var _call2 = _interopRequireDefault(_call);

var _stateParsers = require('./state-parsers');

var _webrtc = require('./webrtc');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Incoming Call Event
 *
 * Emitted when a call begins and when {@link Phone#register} is invoked and
 * there are active calls.
 *
 * @event call:incoming
 * @instance
 * @memberof Phone
 * @type {Object}
 * @property {Call} call The incoming call
 */

/**
 * @class
 * @extends SparkPlugin
 * The calling feature in the SDK is currently available in limited beta. If you'd like to join the beta program and share your feedback, please visit the [developer portal](https://developer.ciscospark.com/sdkaccess/). If you qualify, a Cisco employee will reach out to you.
 */
var Phone = _sparkCore.SparkPlugin.extend({
  derived: {
    /**
     * connected Indicates whether or not the WebSocket is connected
     * @instance
     * @memberof Phone
     * @member {Boolean}
     * @readonly
     */
    connected: {
      deps: ['parent.mercury.connected'],
      // FIXME this prop must be cacheable so it can emit change events
      cache: false,
      fn: function fn() {
        return Boolean(this.spark.mercury.connected);
      }
    },
    /**
     * indicates whether or not the client is registered with the Cisco Spark
     * cloud
     * @instance
     * @memberof Phone
     * @member {Boolean}
     * @readonly
     */
    registered: {
      deps: ['parent.device.url', 'connected'],
      // FIXME this prop must be cacheable so it can emit change events
      cache: false,
      fn: function fn() {
        return Boolean(this.spark.device.url && this.connected);
      }
    }
  },

  namespace: 'phone',

  /**
   * Registers the client with the Cisco Spark cloud and starts listening for
   * WebSocket events.
   *
   * Subsequent calls refresh the device registration.
   * @instance
   * @memberof Phone
   * @returns {Promise}
   */
  register: function register() {
    var _this = this;

    // Ideally, we could call spark.refresh via spark-core, but it doesn't know
    // about the wdm plugin, and all of the leaky abstractions I can think of
    // seem risky.
    return this.spark.device.refresh().then(function () {
      return _this.spark.mercury.connect();
    }).then(function () {
      return _this.spark.locus.list();
    }).then(function (loci) {
      loci.forEach(function (locus) {
        _this.trigger('call:incoming', _call2.default.make({
          locus: locus
        }, {
          parent: _this.spark
        }));
      });
    });
  },


  /**
   * Disconnects from WebSocket and unregisters from the Cisco Spark cloud.
   *
   * Subsequent calls will be a noop.
   * @instance
   * @memberof Phone
   * @returns {Promise}
   */
  deregister: function deregister() {
    // TODO figure out how to hangup all calls (or possibly just disconnect all
    // streams)
    return this.spark.mercury.disconnect();
  },


  /**
   * Create a MediaStream to be used for video preview.
   *
   * Note: You must explicitly pass the resultant stream to {@link Call#answer()}
   * or {@link Phone#dial()}
   * @instance
   * @memberof Phone
   * @param {Object|MediaStreamConstraints} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise<MediaStream>}
   */
  createLocalMediaStream: function createLocalMediaStream(options) {
    // TODO need to figure out a way to manage the stream internally. currently,
    // misuse makes it really easy to lock the camera in the on state.
    options = options || {};
    var constraints = options.constraints || options;
    (0, _defaults2.default)(constraints, {
      audio: true,
      video: true
    });

    return (0, _webrtc.getUserMedia)(constraints);
  },


  /**
   * Initializer
   * @instance
   * @memberof Phone
   * @param {Object} attrs
   * @param {Object} options
   * @private
   * @returns {undefined}
   */
  initialize: function initialize() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_sparkCore.SparkPlugin.prototype.initialize, this, args);

    _pluginLocus.eventKeys.forEach(function (key) {
      _this2.listenTo(_this2.spark.mercury, 'event:' + key, function (event) {
        return _this2._onLocusEvent(event);
      });
    });
  },


  /**
   * Determines if the {@link call:incoming} event should be emitted for the
   * specifed {@link Types~MercuryEvent}
   * @emits call:incoming
   * @instance
   * @memberof Phone
   * @param {Types~MercuryEvent} event
   * @returns {undefined}
   */
  _onLocusEvent: function _onLocusEvent(event) {
    if ((0, _stateParsers.shouldRing)(event, this.spark)) {
      this.trigger('call:incoming', _call2.default.make({
        locus: event.data.locus
      }, {
        parent: this.spark
      }));
    }
  },


  /**
   * Place a call to the specified dialString. A dial string may be an email
   * address or sip uri.
   * @instance
   * @memberof Phone
   * @param {string} dialString
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @param {MediaStream} options.localMediaStream if no stream is specified, a
   * new one will be created based on options.constraints
   * @returns {Call}
   */
  dial: function dial(dialString, options) {
    // TODO call register if it has not been called.
    var call = _call2.default.make({}, { parent: this.spark });

    call.dial(dialString, options);
    return call;
  }
}); /**!
     *
     * Copyright (c) 2016 Cisco Systems, Inc. See LICENSE file.
     * @private
     */

exports.default = Phone;
//# sourceMappingURL=phone.js.map
