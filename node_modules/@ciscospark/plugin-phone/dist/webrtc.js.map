{"version":3,"sources":["../src/webrtc.js"],"names":["getUserMedia","mediaDirection","tracksByKindByStream","storeMediaTrackByKindByStream","getMediaTracksByKindByStream","getVideoTracksByStream","getAudioTracksByStream","startSendingMedia","kind","pc","foundKind","getLocalStreams","forEach","stream","tracks","track","enabled","addTrack","delete","constraints","audio","video","then","addStream","resolve","stopSendingMedia","getTracks","removeTrack","sender","getSenders","s","startReceivingMedia","getRemoteStreams","stopReceivingMedia","receiver","r","reason","console","warn","stopReceivingAudio","stopReceivingVideo","startReceivingAudio","startReceivingVideo","limitBandwith","sdp","split","reduce","lines","line","push","startsWith","includes","join","endAllStreams","reattachTracks","stopStream","stop","reattachTracksForStream","vt","clear","at","startSendingAudio","startSendingVideo","stopSendingAudio","stopSendingVideo","fake","process","env","NODE_ENV","navigator","mediaDevices","createOffer","offerOptions","offerToReceiveVideo","offerToReceiveAudio","promise","onicecandidate","event","candidate","undefined","setTimeout","offer","LOG_SDP","log","setLocalDescription","localDescription","acceptAnswer","setRemoteDescription","RTCSessionDescription","type","end","signalingState","close","curriedAddStream","connectionState","parse","media","direction","remoteSdp","remoteDescription","remoteMedia"],"mappings":"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","file":"webrtc.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\n/* eslint max-nested-callbacks: [0] */\n\nimport 'webrtc-adapter';\nimport transform from 'sdp-transform';\nimport {curry, defaults, find} from 'lodash';\nimport {tap} from '@ciscospark/common';\nimport {\n  addToMappedWeakMappedSet,\n  getMappedWeakMappedSet\n} from './map-utils';\n\nconst tracksByKindByStream = new Map();\nconst storeMediaTrackByKindByStream = addToMappedWeakMappedSet(tracksByKindByStream);\nconst getMediaTracksByKindByStream = getMappedWeakMappedSet(tracksByKindByStream);\nconst getVideoTracksByStream = getMediaTracksByKindByStream(`video`);\nconst getAudioTracksByStream = getMediaTracksByKindByStream(`audio`);\n\nconst startSendingMedia = curry((kind, pc) => {\n  let foundKind = false;\n  pc.getLocalStreams().forEach((stream) => {\n    // Find all the tracks we've removed from the stream/pc so we can readd them\n    const tracks = getMediaTracksByKindByStream(kind, stream);\n    tracks.forEach((track) => {\n      foundKind = foundKind || true;\n      track.enabled = true;\n      // Because adapter.js doesn't actually hide all the cross browser\n      // inconsistencies\n      if (pc.addTrack) {\n        pc.addTrack(track, stream);\n      }\n      else {\n        stream.addTrack(track);\n      }\n    });\n    tracks.delete(stream);\n  });\n\n  // If we didn't find any tracks for this stream/pc, we need to get new media\n  if (!foundKind) {\n    const constraints = {\n      audio: kind === `audio`,\n      video: kind === `video`\n    };\n\n    return getUserMedia(constraints)\n      .then((stream) => addStream(pc, stream));\n  }\n\n  return Promise.resolve();\n});\n\nconst stopSendingMedia = curry((kind, pc) => {\n  pc.getLocalStreams().forEach((stream) => {\n    stream.getTracks().forEach((track) => {\n      if (track.kind === kind) {\n        track.enabled = false;\n        // Store the tracks so we can add them back later (should the user want\n        // to mute/unmute)\n        storeMediaTrackByKindByStream(kind, stream, track);\n        if (pc.removeTrack) {\n          const sender = find(pc.getSenders(), (s) => s.track === track);\n          pc.removeTrack(sender);\n        }\n        else {\n          stream.removeTrack(track);\n        }\n      }\n    });\n  });\n});\n\nconst startReceivingMedia = curry((kind, pc) => {\n  let foundKind = false;\n  pc.getRemoteStreams().forEach((stream) => {\n    // Find all the tracks we've removed from the stream/pc so we can readd them\n    const tracks = getMediaTracksByKindByStream(kind, stream);\n    tracks.forEach((track) => {\n      foundKind = foundKind || true;\n      track.enabled = true;\n      // Because adapter.js doesn't actually hide all the cross browser\n      // inconsistencies\n      if (pc.addTrack) {\n        pc.addTrack(track, stream);\n      }\n      else {\n        stream.addTrack(track);\n      }\n    });\n    tracks.delete(stream);\n  });\n\n  return Promise.resolve();\n});\n\nconst stopReceivingMedia = curry((kind, pc) => {\n  pc.getRemoteStreams().forEach((stream) => {\n    stream.getTracks().forEach((track) => {\n      if (track.kind === kind) {\n        track.enabled = false;\n        // Store the tracks so we can add them back later (should the user want\n        // to mute/unmute)\n        storeMediaTrackByKindByStream(kind, stream, track);\n        if (pc.removeTrack) {\n          const receiver = find(pc.getSenders(), (r) => r.track === track);\n\n          try {\n            pc.removeTrack(receiver);\n          }\n          catch (reason) {\n            // eslint-disable-next-line no-console\n            console.warn(`webrtc: this browser has limited support for renegotiation; receiving ${kind} has been stopped, but will not be renegotiated`);\n          }\n        }\n        else {\n          stream.removeTrack(track);\n        }\n      }\n    });\n  });\n});\n\nexport const stopReceivingAudio = stopReceivingMedia(`audio`);\nexport const stopReceivingVideo = stopReceivingMedia(`video`);\nexport const startReceivingAudio = startReceivingMedia(`audio`);\nexport const startReceivingVideo = startReceivingMedia(`video`);\n\n/**\n * Adds a bandwith limit line to the sdp; without this line, calling fails\n * @param {string} sdp SDP\n * @private\n * @returns {string} The modified SDP\n */\nfunction limitBandwith(sdp) {\n  // TODO can limitBandwith be done with the sender/reciever apis?\n  return sdp.split(`\\r\\n`).reduce((lines, line) => {\n    lines.push(line);\n    if (line.startsWith(`m=`)) {\n      lines.push(`b=TIAS:${line.includes(`audio`) ? 64000 : 1000000}`);\n    }\n    return lines;\n  }, []).join(`\\r\\n`);\n}\n\n/**\n * Ends all streams for the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to end all\n * streams\n * @private\n * @returns {undefined}\n */\nfunction endAllStreams(pc) {\n  reattachTracks(pc);\n  pc.getLocalStreams().forEach(stopStream);\n  pc.getRemoteStreams().forEach(stopStream);\n}\n\n/**\n * Stops the specifed stream's tracks and the stream (depending on browser\n * capabilities)\n * @param {MediaStream} stream The MediaStream to stop\n * @private\n * @returns {undefined}\n */\nfunction stopStream(stream) {\n  // need to reattach any removed tracks (even if they're stopped) to make sure\n  // the camera gets turned off.\n  if (stream.getTracks) {\n    stream.getTracks().forEach((track) => track.stop());\n  }\n\n  if (stream.stop) {\n    stream.stop();\n  }\n}\n\n/**\n * Attaches all tracks that were removed from the specifed RTCPeerConnection\n * (e.g. while muting said tracks). Without reattaching them, the camera may\n * never turn off\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to reattach tracks\n * @private\n * @returns {undefined}\n */\nfunction reattachTracks(pc) {\n  pc.getLocalStreams().forEach(reattachTracksForStream);\n}\n\n/**\n * Reattaches tracks for specifed stream\n * @param {MediaStream} stream The MediaStream to which to reattach tracks\n * @private\n * @returns {undefined}\n */\nfunction reattachTracksForStream(stream) {\n  const vt = getVideoTracksByStream(stream);\n  vt.forEach((track) => stream.addTrack(track));\n  vt.clear();\n\n  const at = getAudioTracksByStream(stream);\n  at.forEach((track) => stream.addTrack(track));\n  at.clear();\n}\n\n/**\n * Stops sending audio via the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop audio\n * @private\n * @returns {Promise}\n */\nexport const startSendingAudio = startSendingMedia(`audio`);\n/**\n * Stops sending video via the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to stop video\n * @private\n * @returns {Promise}\n */\nexport const startSendingVideo = startSendingMedia(`video`);\n/**\n * Starts sending audio via the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start audio\n * @private\n * @returns {Promise}\n */\nexport const stopSendingAudio = stopSendingMedia(`audio`);\n/**\n * Stops sending video via the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc The RTCPeerConnection for which to start video\n * @private\n * @returns {Promise}\n */\nexport const stopSendingVideo = stopSendingMedia(`video`);\n\n/**\n * Wrapper around navigator.mediaDevices.getUserMedia()\n * @param {MediaStreamConstraints} constraints if NODE_ENV is `test`, will\n * automatically add `{fake: true}`. If this is problematic for your use case,\n * you'll need to explicitly include `{fake: false}`\n * @private\n * @returns {Promise<MediaStream>} The resultant MediaStream\n */\nexport function getUserMedia(constraints) {\n  defaults(constraints, {fake: process.env.NODE_ENV === `test`});\n  return navigator.mediaDevices.getUserMedia(constraints);\n}\n\n/**\n * Creates an offer sdp based on the state of the specifed RTCPeerConnection and\n * offer options\n * @param {RTCPeerConnection} pc\n * @param { RTCOfferOptions} offerOptions\n * @private\n * @returns {Promise<string>} Resolves with the offer sdp\n */\nexport const createOffer = curry((pc, offerOptions) => {\n  offerOptions = offerOptions || {};\n  defaults(offerOptions, {\n    offerToReceiveVideo: true,\n    offerToReceiveAudio: true\n  });\n\n  const promise = new Promise((resolve) => {\n    pc.onicecandidate = (event) => {\n      if (!event.candidate) {\n        pc.onicecandidate = undefined;\n        resolve();\n      }\n    };\n\n    setTimeout(() => {\n      pc.onicecandidate = undefined;\n      resolve();\n    }, 500);\n\n  });\n\n  return pc.createOffer(offerOptions)\n    .then(tap((offer) => {offer.sdp = limitBandwith(offer.sdp);}))\n    .then(tap((offer) => {\n      if (process.env.LOG_SDP) {\n        // eslint-disable-next-line no-console\n        console.log(`offer`, offer.sdp);\n      }\n    }))\n    .then((offer) => pc.setLocalDescription(offer))\n    .then(() => Promise.resolve(promise))\n    // Apparently chrome somehow moves the bandwith limit out of the video\n    // section, so we need to reapply it.\n    .then(() => limitBandwith(pc.localDescription.sdp));\n});\n\n/**\n * Applies an incoming answer sdp to the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc\n * @param {string} sdp\n * @private\n * @returns {Promise}\n */\nexport const acceptAnswer = curry((pc, sdp) => {\n  if (process.env.LOG_SDP) {\n    // eslint-disable-next-line no-console\n    console.log(`answer`, sdp);\n  }\n  return pc.setRemoteDescription(new RTCSessionDescription({\n    sdp,\n    type: `answer`\n  }));\n});\n\n/**\n * Terminates the specifed RTCPeerConnection\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {undefined}\n */\nexport const end = curry((pc) => {\n  if (pc.signalingState !== `closed`) {\n    endAllStreams(pc);\n    pc.close();\n  }\n});\n\nconst curriedAddStream = curry(addStream);\n\n/**\n * Adds the specifed stream to the specifed RTCPeerConnection\n * @name addStream\n * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream\n * @param {MediaStream} stream The stream to add\n * @private\n * @returns {undefined}\n */\nexport {curriedAddStream as addStream};\n\n/**\n * Adds the specifed stream to the specifed RTCPeerConnection\n * @param {PeerConnection} pc The RTCPeerConnection to which to add the stream\n * @param {MediaStream} stream The stream to add\n * @private\n * @returns {undefined}\n */\nfunction addStream(pc, stream) {\n  // TODO do either of these return promises?\n  if (pc.addTrack) {\n    stream.getTracks().forEach((track) => pc.addTrack(track, stream));\n  }\n  else {\n    pc.addStream(stream);\n  }\n}\n\n/**\n * returns the direction line for the specifed media type.\n * @param {string} type\n * @param {RTCPeerConnection} pc\n * @private\n * @returns {string}\n */\nexport function mediaDirection(type, pc) {\n  if (pc.connectionState === `closed` || pc.signalingState === `closed`) {\n    return `inactive`;\n  }\n\n  if (!pc.localDescription) {\n    return `inactive`;\n  }\n  const sdp = transform.parse(pc.localDescription.sdp);\n  const media = find(sdp.media, {type});\n  if (!media) {\n    return `inactive`;\n  }\n\n  if (type === `audio` && media.direction === `sendonly`) {\n    const remoteSdp = transform.parse(pc.remoteDescription.sdp);\n    const remoteMedia = find(remoteSdp.media, {type});\n    if (remoteMedia && remoteMedia.direction === `inactive`) {\n      return `inactive`;\n    }\n  }\n\n  return media.direction;\n}\n"]}