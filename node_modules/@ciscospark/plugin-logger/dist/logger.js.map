{"version":3,"sources":["../src/logger.js"],"names":["precedence","silent","error","warn","log","info","debug","trace","levels","filter","level","fallbacks","authTokenKeyPattern","walkAndFilter","object","map","email","test","key","Logger","extend","namespace","derived","cache","fn","getCurrentLevel","session","buffer","type","default","args","arg","Error","process","env","NODE_ENV","window","ret","toString","stack","shouldPrint","config","includes","CISCOSPARK_LOG_LEVEL","spark","device","features","developer","get","forEach","impls","impl","slice","console","pop","prototype","wrappedConsoleMethod","filtered","stringified","item","toPrint","unshift","Date","now","push","length","historyLength","shift","reason"],"mappings":"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","file":"logger.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport {patterns} from '@ciscospark/common';\n\nimport {\n  SparkHttpError,\n  SparkPlugin\n} from '@ciscospark/spark-core';\n\nimport {\n  cloneDeep,\n  isArray,\n  isObject,\n  isString\n} from 'lodash';\n\nconst precedence = {\n  silent: 0,\n  error: 1,\n  warn: 2,\n  log: 3,\n  info: 4,\n  debug: 5,\n  trace: 6\n};\n\nexport const levels = Object.keys(precedence).filter((level) => level !== `silent`);\n\nconst fallbacks = {\n  error: [`log`],\n  warn: [`error`, `log`],\n  info: [`log`],\n  debug: [`info`, `log`],\n  trace: [`debug`, `info`, `log`]\n};\n\nconst authTokenKeyPattern = /[Aa]uthorization/;\n\n/**\n * Recursively strips \"authorization\" fields from the specified object\n * @param {Object} object\n * @returns {Object}\n */\nfunction walkAndFilter(object) {\n  if (isArray(object)) {\n    return object.map(walkAndFilter);\n  }\n  if (!isObject(object)) {\n    if (isString(object)) {\n      if (patterns.email.test(object)) {\n        return `-- REDACTED --`;\n      }\n    }\n    return object;\n  }\n  for (const key in object) {\n    if (authTokenKeyPattern.test(key)) {\n      Reflect.deleteProperty(object, key);\n    }\n    else {\n      object[key] = walkAndFilter(object[key]);\n    }\n  }\n  return object;\n}\n\nconst Logger = SparkPlugin.extend({\n  namespace: `Logger`,\n\n  derived: {\n    level: {\n      cache: false,\n      fn() {\n        return this.getCurrentLevel();\n      }\n    }\n  },\n  session: {\n    buffer: {\n      type: `array`,\n      default() {\n        return [];\n      }\n    }\n  },\n\n  /**\n   * Ensures auth headers don't get printed in logs\n   * @param {Array<mixed>} args\n   * @private\n   * @returns {Array<mixed>}\n   */\n  filter(...args) {\n    return args.map((arg) => {\n      // SparkHttpError already ensures auth tokens don't get printed, so, no\n      // need to alter it here.\n      if (arg instanceof Error) {\n        // karma logs won't print subclassed errors correctly, so we need\n        // explicitly call their tostring methods.\n        if (process.env.NODE_ENV === `test` && typeof window !== `undefined`) {\n          let ret = arg.toString();\n          ret += `BEGIN STACK`;\n          ret += arg.stack;\n          ret += `END STACK`;\n          return ret;\n        }\n\n        return arg;\n      }\n\n      arg = cloneDeep(arg);\n      return walkAndFilter(arg);\n    });\n  },\n\n  /**\n   * Determines if the current level allows logs at the speicified level to be\n   * printed\n   * @param {string} level\n   * @private\n   * @returns {boolean}\n   */\n  shouldPrint(level) {\n    return precedence[level] <= precedence[this.getCurrentLevel()];\n  },\n\n  /**\n   * Indicates the current log level based on env vars, feature toggles, and\n   * user type.\n   * @instance\n   * @memberof Logger\n   * @private\n   * @returns {string}\n   */\n  // eslint-disable-next-line complexity\n  getCurrentLevel() {\n    // If a level has been explicitly set via config, alway use it.\n    if (this.config.level) {\n      return this.config.level;\n    }\n\n    if (levels.includes(process.env.CISCOSPARK_LOG_LEVEL)) {\n      return process.env.CISCOSPARK_LOG_LEVEL;\n    }\n\n    // Always use debug-level logging in test mode;\n    if (process.env.NODE_ENV === `test`) {\n      return `trace`;\n    }\n\n    // Use server-side-feature toggles to configure log levels\n    const level = this.spark.device && this.spark.device.features.developer.get(`log-level`);\n    if (level) {\n      if (levels.includes(level)) {\n        return level;\n      }\n    }\n\n    return `error`;\n  }\n});\n\nlevels.forEach((level) => {\n  let impls = fallbacks[level];\n  let impl = level;\n  if (impls) {\n    impls = impls.slice();\n    // eslint-disable-next-line no-console\n    while (!console[impl]) {\n      impl = impls.pop();\n    }\n  }\n\n  Logger.prototype[level] = function wrappedConsoleMethod(...args) {\n    try {\n      const filtered = this.filter(...args);\n      const stringified = filtered.map((item) => {\n        if (item instanceof SparkHttpError) {\n          return item.toString();\n        }\n        return item;\n      });\n\n      if (this.shouldPrint(level)) {\n        const toPrint = typeof window === `undefined` ? filtered : stringified;\n        // eslint-disable-next-line no-console\n        console[impl](...toPrint);\n      }\n\n      stringified.unshift(Date.now());\n      this.buffer.push(stringified);\n      if (this.buffer.length > this.config.historyLength) {\n        this.buffer.shift();\n      }\n    }\n    catch (reason) {\n      /* istanbul ignore next */\n      // eslint-disable-next-line no-console\n      console.warn(`failed to execute Logger#${level}`, reason);\n    }\n  };\n});\n\nexport default Logger;\n"]}