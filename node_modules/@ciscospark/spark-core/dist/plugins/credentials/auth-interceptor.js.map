{"version":3,"sources":["../../../src/plugins/credentials/auth-interceptor.js"],"names":["AuthInterceptor","options","headers","authorization","all","requiresCredentials","requiresClientCredentials","then","results","spark","credentials","getClientCredentialsAuthorization","getAuthorization","reason","shouldAttemptReauth","logger","info","refresh","force","replay","reject","replayCount","config","maxReplayAttempts","error","Error","request","warn","uri","includes","oauth","tokenUrl","resolve","authorizeUrl","samlUrl","shouldRefreshAccessToken","statusCode"],"mappings":"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","file":"auth-interceptor.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport {Interceptor} from '@ciscospark/http-core';\n\n/**\n * @class\n */\nexport default class AuthInterceptor extends Interceptor {\n  /**\n   * @returns {AuthInterceptor}\n   */\n  static create() {\n    return new AuthInterceptor({spark: this});\n  }\n\n  /**\n   * @see Interceptor#onRequest\n   * @param {Object} options\n   * @returns {Object}\n   */\n  onRequest(options) {\n    // If Authorizations is already set, don't overwrite it\n    if (`authorization` in options.headers) {\n      // If Authorization is set to null, false, or undefined, delete it to\n      // prevent a CORS preflight.\n      if (!options.headers.authorization) {\n        Reflect.deleteProperty(options.headers, `authorization`);\n      }\n      return options;\n    }\n\n    return Promise.all([\n      this.requiresCredentials(options),\n      this.requiresClientCredentials(options)\n    ])\n      .then((results) => {\n        const [requiresCredentials, requiresClientCredentials] = results;\n        if (requiresClientCredentials) {\n          return this.spark.credentials.getClientCredentialsAuthorization();\n        }\n        else if (requiresCredentials) {\n          return this.spark.credentials.getAuthorization();\n        }\n        return null;\n      })\n      .then((authorization) => {\n        options.headers.authorization = authorization;\n        return options;\n      });\n  }\n\n  /**\n   * @see Interceptor#onResponseError\n   * @param {Object} options\n   * @param {Error} reason\n   * @returns {Object}\n   */\n  onResponseError(options, reason) {\n    return this.shouldAttemptReauth(reason, options)\n      .then((shouldAttemptReauth) => {\n        if (shouldAttemptReauth) {\n          this.spark.logger.info(`auth: received 401, attempting to reauthenticate`);\n\n          if (reason.options.headers) {\n            Reflect.deleteProperty(reason.options.headers, `authorization`);\n          }\n\n          return this.spark.refresh({force: true})\n            .then(() => this.replay(options));\n        }\n\n        return Promise.reject(reason);\n      });\n  }\n\n  /**\n   * Replays the request\n   * @param {Object} options\n   * @returns {Object}\n   */\n  replay(options) {\n    options.replayCount = options.replayCount || 1;\n\n    this.spark.logger.info(`auth: replaying request ${options.replayCount} time`);\n\n    if (options.replayCount > this.spark.config.maxReplayAttempts) {\n      this.spark.logger.error(`auth: failed after ${this.spark.config.maxReplayAttempts} replay attempts`);\n      return Promise.reject(new Error(`Failed after ${this.spark.config.maxReplayAttempts} replay attempts`));\n    }\n\n    return this.spark.request(options);\n  }\n\n  /**\n   * Indicates whether or not the current request requires credentials\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresCredentials(options) {\n    this.spark.logger.warn(`AuthInterceptor: #requiresCredentials should be overridden`);\n    if (options.uri.includes(this.spark.config.credentials.oauth.tokenUrl)) {\n      return Promise.resolve(false);\n    }\n\n    if (options.uri.includes(this.spark.config.credentials.oauth.authorizeUrl)) {\n      return Promise.resolve(false);\n    }\n\n    if (options.uri.includes(this.spark.config.credentials.samlUrl)) {\n      return Promise.resolve(false);\n    }\n\n    return Promise.resolve(true);\n  }\n\n  /**\n   * Indicates whether or not the current request requires client credentials.\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  requiresClientCredentials(options) {\n    return options.requiresClientCredentials;\n  }\n\n  /**\n   * Indicates whether or not the current request should refresh its access\n   * token in event of a 401\n   * @param {Error} reason\n   * @param {Object} options\n   * @returns {Promise<boolean>}\n   */\n  shouldAttemptReauth(reason, options) {\n    if (options && options.shouldRefreshAccessToken === false) {\n      return Promise.resolve(false);\n    }\n\n    if (options && options.requiresClientCredentials) {\n      return Promise.resolve(false);\n    }\n\n    if (reason.statusCode === 401) {\n      return Promise.resolve(true);\n    }\n\n    return Promise.resolve(false);\n  }\n}\n"]}