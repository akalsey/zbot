'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _pick = require('lodash/pick');

var _pick2 = _interopRequireDefault(_pick);

var _dec, _dec2, _desc, _value, _obj; /**!
                                       *
                                       * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
                                       * @private
                                       */

var _authorization = require('../authorization');

var _authorization2 = _interopRequireDefault(_authorization);

var _common = require('@ciscospark/common');

var _grantErrors = require('../grant-errors');

var _grantErrors2 = _interopRequireDefault(_grantErrors);

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _sparkPlugin = require('../../../lib/spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

var _storage = require('../../../lib/storage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

/**
 * Helper. Returns just the response body
 * @param {http.IncomingMessage} res
 * @returns {Object}
 */
function resolveWithResponseBody(res) {
  return res.body;
}

/**
 * Helper. Converts a response body into an Authorization object
 * @param {http.IncomingMessage} res
 * @returns {Authorization}
 */
function processGrant(res) {
  return new _authorization2.default(res.body);
}

exports.default = (_dec = (0, _storage.waitForValue)('authorization'), _dec2 = (0, _storage.waitForValue)('clientAuthorization'), (_obj = {
  derived: {
    canRefresh: {
      deps: ['authorization.canRefresh'],
      fn: function fn() {
        if (this.config.requestJWT) {
          return true;
        }
        /* eslint camelcase: [0] */
        return Boolean(this.config.oauth.client_id && this.config.oauth.client_secret && this.authorization && this.authorization.canRefresh);
      }
    },
    isAuthenticated: {
      deps: ['authorization.isAuthenticated'],
      fn: function fn() {
        return Boolean(this.authorization && this.authorization.isAuthenticated);
      }
    },
    isAuthenticating: {
      deps: ['authorization.isRefreshing', '_isAuthenticating'],
      fn: function fn() {
        return this._isAuthenticating || this.authorization && this.authorization.isRefreshing;
      }
    },
    isExpired: {
      deps: ['authorization.isExpired'],
      fn: function fn() {
        return Boolean(this.authorization && this.authorization.isExpired);
      }
    }
  },

  namespace: 'Credentials',

  props: {
    authorization: {
      type: 'state'
    },
    clientAuthorization: {
      type: 'state'
    },
    name: {
      setOnce: true,
      type: 'string'
    },
    orgId: {
      setOnce: true,
      type: 'string'
    }
  },

  session: {
    _isAuthenticating: {
      default: false,
      type: 'boolean'
    },
    password: 'string',
    previousAuthorization: {
      type: 'state'
    }
  },

  authenticate: function authenticate() {
    return this.authorize.apply(this, arguments);
  },
  authorize: function authorize(options) {
    var _this = this;

    /* eslint no-invalid-this: [0] */
    this._isAuthenticating = true;
    options = options || {};
    if (options.code) {
      this.logger.info('credentials: auth code received, exchanging for access_token');
      return this.requestAuthorizationCodeGrant(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      });
    }

    if (options.jwt) {
      return this.requestAccessTokenFromJwt(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      });
    }

    if (this.canRefresh) {
      this.logger.info('credentials: refreshable, refreshing');
      return this.refresh(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      });
    }

    this.set((0, _pick2.default)(options, 'name', 'orgId', 'password'));

    if (this.name && this.orgId && this.password) {
      this.logger.info('credentials: machine credentials received, authenticating');
      return this.requestSamlExtensionGrant(options).then(function (res) {
        _this._isAuthenticating = false;
        return res;
      }).catch(function (res) {
        _this._isAuthenticating = false;
        return _promise2.default.reject(res);
      });
    }

    this._isAuthenticating = false;
    return _promise2.default.reject(new Error('not enough parameters to authenticate'));
  },
  getAuthorization: function getAuthorization() {
    var _this2 = this;

    if (this.isAuthenticated) {
      if (this.isExpired) {
        if (this.canRefresh) {
          return this.refresh().then(function () {
            return _this2.authorization.toString();
          });
        }

        return _promise2.default.reject(new Error('Access token has expired or cannot be refreshed'));
      }

      return _promise2.default.resolve(this.authorization.toString());
    }

    return _promise2.default.reject(new Error('not authenticated'));
  },
  getClientCredentialsAuthorization: function getClientCredentialsAuthorization() {
    var _this3 = this;

    var promise = void 0;
    if (!this.clientAuthorization || !this.clientAuthorization.isAuthenticated || this.clientAuthorization.isExpired) {
      promise = this.requestClientCredentialsGrant();
    } else {
      promise = _promise2.default.resolve();
    }

    return promise.then(function () {
      return _this3.clientAuthorization.toString();
    });
  },


  /**
   * @returns {Promise}
   */
  logout: function logout() {
    var _this4 = this;

    return _promise2.default.all(['authorization', 'previousAuthorization'].map(function (key) {
      if (_this4[key]) {
        return _this4[key].revoke().then(function () {
          return _this4.unset(key);
        }).then(function () {
          return _this4.boundedStorage.del(key);
        }).catch(function (reason) {
          _this4.logger.error('credentials: ' + key + ' revocation falied', reason);
        });
      }
      return _promise2.default.resolve();
    }));
  },
  refresh: function refresh(options) {
    var _this5 = this;

    /* eslint no-invalid-this: [0] */
    this.logger.info('credentials: refresh requested');

    options = options || {};

    if (!options.force && !(0, _get2.default)(this, 'authorization.isExpired')) {
      this.logger.info('credentials: authorization not expired, not refreshing');
      return _promise2.default.resolve();
    }

    this.logger.info('credentials: refreshing');

    if (this.config.requestJWT) {
      this.logger.info('credentials: request new jwt');
      return this.config.requestJWT().then(function (jwt) {
        return _this5.requestAccessTokenFromJwt(jwt);
      });
    }

    return this.authorization.refresh(options).then(this._pushAuthorization.bind(this)).catch(this._handleRefreshFailure.bind(this));
  },
  requestAccessTokenFromJwt: function requestAccessTokenFromJwt(options) {
    this.logger.info('credentials: exchanging jwt for access token');
    return this.spark.request({
      method: 'POST',
      // I'm not thrilled by directly referencing the hydra service url, but
      // since the spark-core credentials plugin is on the march toward
      // deprecation, I think it's tolerable for now.
      uri: this.config.hydraServiceUrl + '/jwt/login',
      headers: {
        authorization: options.jwt
      }
    }).then(function (res) {
      return {
        body: {
          access_token: res.body.token,
          token_type: 'Bearer',
          expires_in: res.body.expiresIn
        }
      };
    }).then(processGrant).then(this._pushAuthorization.bind(this));
  },
  requestAuthorizationCodeGrant: function requestAuthorizationCodeGrant(options) {
    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET',
      'oauth.redirect_uri': 'REDIRECT_URI'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    /* eslint camelcase: [0] */
    this.logger.info('credentials: requesting authorization code grant');

    options = options || {};
    options.scope = options.scope || this.config.oauth.scope;

    if (!options.code) {
      return _promise2.default.reject(new Error('`options.code` is required'));
    }

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        grant_type: 'authorization_code',
        redirect_uri: this.config.oauth.redirect_uri,
        code: options.code
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(processGrant).then(this._pushAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  },
  requestClientCredentialsGrant: function requestClientCredentialsGrant(options) {
    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    this.logger.info('credentials: requesting client credentials grant');

    options = options || {};
    // Right now, admin is the only service that needs Client Credentials,
    // so we`ll hard code that here. long term, we`ll want to keep track of
    // scope used to request a specific token and (potentially) specify
    // scope as an options passed to Clinet#request so it can pick the right
    // token.
    options.scope = options.scope || 'webexsquare:admin';

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        grant_type: 'client_credentials',
        scope: options.scope,
        shouldRefreshAccessToken: false
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      }
    }).then(processGrant).then(this._pushClientCredentialsAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  },
  requestSamlExtensionGrant: function requestSamlExtensionGrant(options) {
    options = options || {};
    options.scope = options.scope || this.config.oauth.scope;

    this.logger.info('credentials: requesting SAML extension grant');

    return this._getSamlBearerToken(options).then(this._getOauthBearerToken.bind(this, options)).then(processGrant).then(this._pushAuthorization.bind(this)).catch(function (res) {
      if (res.statusCode !== 400) {
        return _promise2.default.reject(res);
      }

      var ErrorConstructor = _grantErrors2.default.select(res.body.error);
      return _promise2.default.reject(new ErrorConstructor(res._res || res));
    });
  },
  set: function set(key, value) {
    var _this6 = this;

    var attrs = void 0;
    if ((0, _isObject2.default)(key)) {
      attrs = key;
    } else {
      attrs = {};
      attrs[key] = value;
    }

    ['authorization', 'clientAuthorization', 'previousAuthorization'].forEach(function (propName) {
      if (attrs[propName]) {
        if (!(attrs[propName] instanceof _authorization2.default)) {
          attrs[propName] = new _authorization2.default(attrs[propName]);
        }
        attrs[propName].parent = _this6;
      }
    });

    /* eslint prefer-rest-params: [0] */
    return (0, _apply2.default)(_sparkPlugin2.default.prototype.set, this, arguments);
  },
  buildLogoutUrl: function buildLogoutUrl() {
    // eslint doesn't yet handle nested strings quite right
    /* eslint quotes: [0] */
    return this.config.logoutUri + '?' + _querystring2.default.stringify({
      type: 'logout',
      goto: this.config.oauth.redirect_uri,
      service: this.config.oauth.service
    });
  },
  buildOAuthUrl: function buildOAuthUrl(options) {
    var _this7 = this;

    /* eslint camelcase: [0] */
    var fields = ['client_id', 'redirect_uri', 'scope', 'service'];

    var parameters = (0, _clone2.default)(options);

    parameters.state = parameters.state || {};
    if (!(0, _isObject2.default)(parameters.state)) {
      throw new Error('if specified, `options.state` must be an object');
    }

    if (!parameters.response_type) {
      throw new Error('`options.response_type` is required');
    }

    fields.forEach(function (key) {
      if (key in _this7.config.oauth) {
        parameters[key] = _this7.config.oauth[key];
      } else {
        throw new Error('`' + key + '` is required');
      }
    }, this);

    // Some browser aparently don't parse nested querystrings very well, so
    // we'll additionally base64url-encode the state
    parameters.state = _common.base64.toBase64Url(_querystring2.default.stringify(parameters.state));
    return this.config.oauth.authorizationUrl + '?' + _querystring2.default.stringify(parameters);
  },
  _getOauthBearerToken: function _getOauthBearerToken(options, samlData) {
    this.logger.info('credentials: exchanging SAML Bearer Token for OAuth Bearer Token');

    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        /* eslint camelcase: [0] */
        grant_type: 'urn:ietf:params:oauth:grant-type:saml2-bearer',
        assertion: samlData.BearerToken,
        scope: options.scope
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    });
  },
  _getSamlBearerToken: function _getSamlBearerToken() {
    this.logger.info('credentials: requesting SAML Bearer Token');

    if (!this.orgId) {
      return _promise2.default.reject(new Error('`this.orgId` is required'));
    }

    if (!this.name) {
      return _promise2.default.reject(new Error('`this.name` is required'));
    }

    if (!this.password) {
      return _promise2.default.reject(new Error('`this.password` is required'));
    }

    return this.request({
      method: 'POST',
      uri: this.config.samlUrl + '/' + this.orgId + '/v2/actions/GetBearerToken/invoke',
      body: (0, _pick2.default)(this, 'name', 'password'),
      shouldRefreshAccessToken: false
    }).then(resolveWithResponseBody);
  },
  _handleRefreshFailure: function _handleRefreshFailure(res) {
    if (res.error && res.error === 'invalid_request') {
      this.logger.warn('token refresh failed: ', res.errorDescription);
      this.unset('authorization');
    }

    return _promise2.default.reject(res);
  },
  _pushClientCredentialsAuthorization: function _pushClientCredentialsAuthorization(authorization) {
    this.logger.info('credentials: received client credentials');

    this.clientAuthorization = authorization;
  },
  _pushAuthorization: function _pushAuthorization(authorization) {
    this.logger.info('credentials: received authorization');

    var previousAuthorization = this.previousAuthorization;
    this.previousAuthorization = this.authorization;
    this.authorization = authorization;

    if (previousAuthorization) {
      previousAuthorization.revoke();
    }
  }
}, (_applyDecoratedDescriptor(_obj, 'getAuthorization', [_common.oneFlight, _dec], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getAuthorization'), _obj), _applyDecoratedDescriptor(_obj, 'getClientCredentialsAuthorization', [_common.oneFlight, _dec2], (0, _getOwnPropertyDescriptor2.default)(_obj, 'getClientCredentialsAuthorization'), _obj), _applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'requestAccessTokenFromJwt', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestAccessTokenFromJwt'), _obj), _applyDecoratedDescriptor(_obj, 'requestAuthorizationCodeGrant', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestAuthorizationCodeGrant'), _obj), _applyDecoratedDescriptor(_obj, 'requestClientCredentialsGrant', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestClientCredentialsGrant'), _obj), _applyDecoratedDescriptor(_obj, 'requestSamlExtensionGrant', [_common.oneFlight, _common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, 'requestSamlExtensionGrant'), _obj), _applyDecoratedDescriptor(_obj, '_getOauthBearerToken', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_getOauthBearerToken'), _obj), _applyDecoratedDescriptor(_obj, '_getSamlBearerToken', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, '_getSamlBearerToken'), _obj)), _obj));
//# sourceMappingURL=common.js.map
