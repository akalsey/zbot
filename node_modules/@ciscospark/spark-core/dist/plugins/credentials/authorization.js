'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _pick = require('lodash/pick');

var _pick2 = _interopRequireDefault(_pick);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _desc, _value, _obj; /**!
                          *
                          * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
                          * @private
                          */

/* eslint camelcase: [0] */

var _grantErrors = require('./grant-errors');

var _grantErrors2 = _interopRequireDefault(_grantErrors);

var _common = require('@ciscospark/common');

var _sparkPlugin = require('../../lib/spark-plugin');

var _sparkPlugin2 = _interopRequireDefault(_sparkPlugin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var AuthorizationBase = _sparkPlugin2.default.extend((_obj = {
  derived: {
    canRefresh: {
      deps: ['refresh_token'],
      fn: function fn() {
        return Boolean(this.refresh_token);
      }
    },

    isAuthenticated: {
      deps: ['access_token', 'refresh_token'],
      fn: function fn() {
        return Boolean(this.access_token || this.refresh_token);
      }
    },

    isExpired: {
      cache: false,
      deps: ['access_token', 'expires'],
      fn: function fn() {
        // if we don't have an access token, it can't actually be expired
        return !this.access_token || Boolean(this.access_token && this.expires && Date.now() > this.expires);
      }
    },

    isValid: {
      cache: false,
      deps: ['access_token', 'isExpired', 'canRefresh'],
      fn: function fn() {
        return this.access_token && !this.isExpired || this.canRefresh;
      }
    }
  },

  namespace: 'Credentials',

  props: {
    access_token: 'string',
    expires: 'number',
    expires_in: 'number',
    refresh_token: 'string',
    refresh_token_expires: 'number',
    refresh_token_expires_in: 'number',
    token_type: {
      default: 'Bearer',
      type: 'string'
    }
  },

  session: {
    isRefreshing: {
      default: false,
      type: 'boolean'
    }
  },

  toString: function toString() {
    if (this.token_type && this.access_token) {
      return this.token_type + ' ' + this.access_token;
    }
    return '';
  },
  initialize: function initialize() {
    var now = Date.now();

    if (!this.expires && this.expires_in) {
      this.expires = now + this.expires_in * 1000;
    }

    if (!this.refresh_token_expires && this.refresh_token_expires_in) {
      this.refresh_token_expires = now + this.refresh_token_expires_in * 1000;
    }

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (0, _apply2.default)(_sparkPlugin2.default.prototype.initialize, this, args);
  },
  refresh: function refresh() {
    var _this = this;

    /* eslint no-invalid-this: [0] */
    if (!this.canRefresh) {
      return _promise2.default.reject(new Error('Authorization cannot be refreshed'));
    }

    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET',
      'oauth.redirect_uri': 'REDIRECT_URI'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    this.isRefreshing = true;

    this.logger.info('authorization: refreshing access token');

    return this.request({
      method: 'POST',
      uri: this.config.oauth.tokenUrl,
      form: {
        grant_type: 'refresh_token',
        redirect_uri: this.config.oauth.redirect_uri,
        refresh_token: this.refresh_token
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(function (res) {
      // If the authentication server did not send back a refresh_token, copy
      // the current refresh token and related values onto the response.
      if (!res.body.refresh_token) {
        (0, _assign2.default)(res.body, (0, _pick2.default)(_this, 'refresh_token', 'refresh_token_expires', 'refresh_token_expires_in'));
      }

      _this.logger.info('authorization: access token refreshed');

      // this.constructor *should* be Authorization. We can`t use it by name
      // because this file defines AuthorizationBase.
      return new _this.constructor(res.body);
    }).catch(function (reason) {
      if (reason.statusCode !== 400) {
        return _promise2.default.reject(reason);
      }

      var ErrorConstructor = _grantErrors2.default.select(reason.body.error);
      return _promise2.default.reject(new ErrorConstructor(reason._res || reason));
    }).then(function (res) {
      _this.isRefreshing = false;
      return res;
    }).catch(function (res) {
      _this.isRefreshing = false;
      return _promise2.default.reject(res);
    });
  },
  revoke: function revoke() {
    var _this2 = this;

    /* eslint no-invalid-this: [0] */
    if (this.isExpired || !this.isValid) {
      this.logger.info('authorization: access token already expired or invalid, not revoking');

      return _promise2.default.resolve();
    }

    this.logger.info('authorization: revoking access token');

    var vars = {
      'oauth.client_id': 'CLIENT_ID',
      'oauth.client_secret': 'CLIENT_SECRET'
    };

    for (var key in vars) {
      if (!(0, _has2.default)(this.config, key)) {
        var baseVar = vars[key];
        return _promise2.default.reject(new Error('config.credentials.' + key + ' or CISCOSPARK_' + baseVar + ' or COMMON_IDENTITY_' + baseVar + ' or ' + baseVar + ' must be defined'));
      }
    }

    return this.request({
      method: 'POST',
      uri: this.config.oauth.revokeUrl,
      form: {
        token: this.access_token,
        token_type_hint: 'access_token'
      },
      auth: {
        user: this.config.oauth.client_id,
        pass: this.config.oauth.client_secret,
        sendImmediately: true
      },
      shouldRefreshAccessToken: false
    }).then(function (res) {
      _this2.logger.info('authorization: authorization revoked');
      _this2.unset((0, _keys2.default)(_this2.getAttributes({ props: true })));
      return res;
    }).catch(function (reason) {
      if (reason.statusCode !== 400) {
        return _promise2.default.reject(reason);
      }

      var ErrorConstructor = _grantErrors2.default.select(reason.body.error);
      return _promise2.default.reject(new ErrorConstructor(reason._res || reason));
    });
  }
}, (_applyDecoratedDescriptor(_obj, 'refresh', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'refresh'), _obj), _applyDecoratedDescriptor(_obj, 'revoke', [_common.oneFlight], (0, _getOwnPropertyDescriptor2.default)(_obj, 'revoke'), _obj)), _obj));

exports.default = AuthorizationBase;
//# sourceMappingURL=authorization.js.map
