{"version":3,"sources":["../../src/lib/spark-plugin.js"],"names":["SparkPlugin","extend","derived","boundedStorage","deps","fn","unboundedStorage","config","cache","spark","namespace","getNamespace","toLowerCase","logger","console","parent","collection","Error","session","type","clear","options","attributes","forEach","key","unset","_children","_collections","reset","initialize","args","prototype","cloned","_dataTypes","dataType","set","bind","on","model","trigger","inspect","depth","serialize","request","upload","when","eventName","resolve","once"],"mappings":"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","file":"spark-plugin.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport AmpState from 'ampersand-state';\nimport util from 'util';\nimport {cloneDeep} from 'lodash';\nimport {makeSparkPluginStore} from './storage';\n\nconst SparkPlugin = AmpState.extend({\n  derived: {\n    boundedStorage: {\n      deps: [],\n      fn() {\n        return makeSparkPluginStore(`bounded`, this);\n      }\n    },\n    unboundedStorage: {\n      deps: [],\n      fn() {\n        return makeSparkPluginStore(`unbounded`, this);\n      }\n    },\n    config: {\n      // figure out why caching config breaks the refresh integration test\n      // but not the refresh automation test.\n      cache: false,\n      deps: [\n        `spark`,\n        `spark.config`\n      ],\n      fn() {\n        if (this.spark && this.spark.config) {\n          const namespace = this.getNamespace();\n          if (namespace) {\n            return this.spark.config[namespace.toLowerCase()];\n          }\n\n          return this.spark.config;\n        }\n\n        return {};\n      }\n    },\n\n    logger: {\n      deps: [\n        `spark`,\n        `spark.logger`\n      ],\n      fn() {\n        return this.spark.logger || console;\n      }\n    },\n\n    spark: {\n      deps: [`parent`],\n      fn() {\n        if (!this.parent && !this.collection) {\n          throw new Error(`Cannot determine \\`this.spark\\` without \\`this.parent\\` or \\`this.collection\\`. Please initialize \\`this\\` via \\`children\\` or \\`collection\\` or set \\`this.parent\\` manually`);\n        }\n\n        /* eslint consistent-this: [0] */\n        let parent = this;\n        while (parent.parent || parent.collection) {\n          parent = parent.parent || parent.collection;\n        }\n\n        return parent;\n      }\n    }\n  },\n\n  session: {\n    parent: {\n      type: `any`\n    }\n  },\n\n  /**\n   * Overrides AmpersandState#clear to make sure we never unset `parent` and\n   * recursively visits children/collections.\n   * @param {Object} options\n   * @returns {SparkPlugin}\n   */\n  clear(options) {\n    Object.keys(this.attributes).forEach((key) => {\n      if (key !== `parent`) {\n        this.unset(key, options);\n      }\n    });\n\n    Object.keys(this._children).forEach((key) => {\n      this[key].clear();\n    });\n\n    Object.keys(this._collections).forEach((key) => {\n      this[key].reset();\n    });\n\n    return this;\n  },\n\n  initialize(...args) {\n    Reflect.apply(AmpState.prototype.initialize, this, args);\n\n    // This is a bit of a hack to allow makeStateDataType work\n    let cloned = false;\n    Object.keys(this._dataTypes).forEach((key) => {\n      const dataType = this._dataTypes[key];\n      if (dataType.set) {\n        if (!cloned) {\n          this._dataTypes = cloneDeep(this._dataTypes);\n          cloned = true;\n        }\n        dataType.set = dataType.set.bind(this);\n      }\n    });\n\n    // Propagate change:[attribute] events from children\n    this.on(`change`, (model, options) => {\n      if (this.parent) {\n        this.parent.trigger(`change:${this.getNamespace().toLowerCase()}`, this.parent, this, options);\n      }\n    });\n  },\n\n  /**\n   * @param {number} depth\n   * @returns {Object}\n   */\n  inspect(depth) {\n    return util.inspect(this.serialize(), {depth});\n  },\n\n  request(...args) {\n    return this.spark.request(...args);\n  },\n\n  upload(...args) {\n    return this.spark.upload(...args);\n  },\n\n  when(eventName) {\n    return new Promise((resolve) => {\n      this.once(eventName, (...args) => resolve(args));\n    });\n  }\n});\n\nexport default SparkPlugin;\n"]}