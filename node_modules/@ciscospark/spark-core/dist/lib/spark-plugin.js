'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _cloneDeep = require('lodash/cloneDeep');

var _cloneDeep2 = _interopRequireDefault(_cloneDeep);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _util = require('util');

var _util2 = _interopRequireDefault(_util);

var _storage = require('./storage');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SparkPlugin = _ampersandState2.default.extend({
  derived: {
    boundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkPluginStore)('bounded', this);
      }
    },
    unboundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkPluginStore)('unbounded', this);
      }
    },
    config: {
      // figure out why caching config breaks the refresh integration test
      // but not the refresh automation test.
      cache: false,
      deps: ['spark', 'spark.config'],
      fn: function fn() {
        if (this.spark && this.spark.config) {
          var namespace = this.getNamespace();
          if (namespace) {
            return this.spark.config[namespace.toLowerCase()];
          }

          return this.spark.config;
        }

        return {};
      }
    },

    logger: {
      deps: ['spark', 'spark.logger'],
      fn: function fn() {
        return this.spark.logger || console;
      }
    },

    spark: {
      deps: ['parent'],
      fn: function fn() {
        if (!this.parent && !this.collection) {
          throw new Error('Cannot determine `this.spark` without `this.parent` or `this.collection`. Please initialize `this` via `children` or `collection` or set `this.parent` manually');
        }

        /* eslint consistent-this: [0] */
        var parent = this;
        while (parent.parent || parent.collection) {
          parent = parent.parent || parent.collection;
        }

        return parent;
      }
    }
  },

  session: {
    parent: {
      type: 'any'
    }
  },

  /**
   * Overrides AmpersandState#clear to make sure we never unset `parent` and
   * recursively visits children/collections.
   * @param {Object} options
   * @returns {SparkPlugin}
   */
  clear: function clear(options) {
    var _this = this;

    (0, _keys2.default)(this.attributes).forEach(function (key) {
      if (key !== 'parent') {
        _this.unset(key, options);
      }
    });

    (0, _keys2.default)(this._children).forEach(function (key) {
      _this[key].clear();
    });

    (0, _keys2.default)(this._collections).forEach(function (key) {
      _this[key].reset();
    });

    return this;
  },
  initialize: function initialize() {
    var _this2 = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    (0, _apply2.default)(_ampersandState2.default.prototype.initialize, this, args);

    // This is a bit of a hack to allow makeStateDataType work
    var cloned = false;
    (0, _keys2.default)(this._dataTypes).forEach(function (key) {
      var dataType = _this2._dataTypes[key];
      if (dataType.set) {
        if (!cloned) {
          _this2._dataTypes = (0, _cloneDeep2.default)(_this2._dataTypes);
          cloned = true;
        }
        dataType.set = dataType.set.bind(_this2);
      }
    });

    // Propagate change:[attribute] events from children
    this.on('change', function (model, options) {
      if (_this2.parent) {
        _this2.parent.trigger('change:' + _this2.getNamespace().toLowerCase(), _this2.parent, _this2, options);
      }
    });
  },


  /**
   * @param {number} depth
   * @returns {Object}
   */
  inspect: function inspect(depth) {
    return _util2.default.inspect(this.serialize(), { depth: depth });
  },
  request: function request() {
    var _spark;

    return (_spark = this.spark).request.apply(_spark, arguments);
  },
  upload: function upload() {
    var _spark2;

    return (_spark2 = this.spark).upload.apply(_spark2, arguments);
  },
  when: function when(eventName) {
    var _this3 = this;

    return new _promise2.default(function (resolve) {
      _this3.once(eventName, function () {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return resolve(args);
      });
    });
  }
}); /**!
     *
     * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
     * @private
     */

exports.default = SparkPlugin;
//# sourceMappingURL=spark-plugin.js.map
