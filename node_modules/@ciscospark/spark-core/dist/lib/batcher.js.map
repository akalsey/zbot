{"version":3,"sources":["../../src/lib/batcher.js"],"names":["Batcher","extend","session","deferreds","type","default","queue","derived","bounce","fn","executeQueue","config","batcherWait","maxCalls","batcherMaxCalls","maxWait","batcherMaxWait","request","item","defer","fingerprintRequest","then","idx","has","resolve","get","promise","set","prepareItem","req","delete","catch","reason","reject","enqueue","push","splice","prepareRequest","payload","submitHttpRequest","res","handleHttpSuccess","handleHttpError","all","map","getDeferredForRequest","logger","error","process","env","NODE_ENV","stack","Error","body","items","acceptItem","msg","message","options","didItemFail","didFail","handleItemFailure","handleItemSuccess","getDeferredForResponse","fingerprintResponse"],"mappings":"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","file":"batcher.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport SparkPlugin from './spark-plugin';\nimport {\n  cappedDebounce,\n  Defer\n} from '@ciscospark/common';\nimport SparkHttpError from './spark-http-error';\n\n/**\n * Base class for coalescing requests to batched APIs\n * @class Batcher\n */\nconst Batcher = SparkPlugin.extend({\n  session: {\n    deferreds: {\n      type: `object`,\n      default() {\n        return new Map();\n      }\n    },\n    queue: {\n      type: `array`,\n      default() {\n        return [];\n      }\n    }\n  },\n\n  derived: {\n    bounce: {\n      fn() {\n        return cappedDebounce((...args) => this.executeQueue(...args), this.config.batcherWait, {\n          maxCalls: this.config.batcherMaxCalls,\n          maxWait: this.config.batcherMaxWait\n        });\n      }\n    }\n  },\n\n  /**\n   * Requests an item from a batched API\n   * @param {Object} item\n   * @returns {Promise<mixed>}\n   */\n  request(item) {\n    // So far, I can't find a way to avoid three layers of nesting here.\n    /* eslint max-nested-callbacks: [0] */\n    const defer = new Defer();\n    this.fingerprintRequest(item)\n      .then((idx) => {\n        if (this.deferreds.has(idx)) {\n          defer.resolve(this.deferreds.get(idx).promise);\n          return;\n        }\n        this.deferreds.set(idx, defer);\n        this.prepareItem(item)\n          .then((req) => {\n            defer.promise = defer.promise\n              .then(() => this.deferreds.delete(idx))\n              .catch((reason) => {\n                this.deferreds.delete(idx);\n                return Promise.reject(reason);\n              });\n\n            this.enqueue(req)\n              .then(() => this.bounce())\n              .catch((reason) => defer.reject(reason));\n          })\n          .catch((reason) => defer.reject(reason));\n      })\n      .catch((reason) => defer.reject(reason));\n\n    return defer.promise;\n  },\n\n  /**\n   * Adds an item to the queue.\n   * Intended to be overridden\n   * @param {mixed} req\n   * @returns {Promise<undefined>}\n   */\n  enqueue(req) {\n    this.queue.push(req);\n    return Promise.resolve();\n  },\n\n  /**\n   * Transform the item before adding it to the queue\n   * Intended to be overridden\n   * @param {mixed} item\n   * @returns {Promise<mixed>}\n   */\n  prepareItem(item) {\n    return Promise.resolve(item);\n  },\n\n  /**\n   * Detaches the current queue, does any appropriate transforms, and submits it\n   * to the API.\n   * @returns {Promise<undefined>}\n   */\n  executeQueue() {\n    const queue = this.queue.splice(0);\n    return new Promise((resolve) => {\n      resolve(this.prepareRequest(queue)\n        .then((payload) => this.submitHttpRequest(payload)\n          .then((res) => this.handleHttpSuccess(res)))\n          .catch((reason) => {\n            if (reason instanceof SparkHttpError) {\n              return this.handleHttpError(reason);\n            }\n\n            return Promise.all(queue.map((item) => this.getDeferredForRequest(item)\n              .then((defer) => {\n                defer.reject(reason);\n              })));\n          })\n        );\n    })\n      .catch((reason) => {\n        this.logger.error(process.env.NODE_ENV === `production` ? reason : reason.stack);\n        return Promise.reject(reason);\n      });\n  },\n\n  /**\n   * Performs any final transforms on the queue before submitting it to the API\n   * Intended to be overridden\n   * @param {Object|Array} queue\n   * @returns {Promise<Object>}\n   */\n  prepareRequest(queue) {\n    return Promise.resolve(queue);\n  },\n\n  /**\n   * Submits the prepared request body to the API.\n   * This method *must* be overridden\n   * @param {Object} payload\n   * @returns {Promise<HttpResponseObject>}\n   */\n  // eslint-disable-next-line no-unused-vars\n  submitHttpRequest(payload) {\n    throw new Error(`request() must be implemented`);\n  },\n\n  /**\n   * Actions taken when the http request returns a success\n   * Intended to be overridden\n   * @param {Promise<HttpResponseObject>} res\n   * @returns {Promise<undefined>}\n   */\n  handleHttpSuccess(res) {\n    return Promise.all((res.body && res.body.items || res.body).map((item) => this.acceptItem(item)));\n  },\n\n  /**\n   * Actions taken when the http request returns a failure. Typically, this\n   * means failing the entire queue, but could be overridden in some\n   * implementations to e.g. reenqueue.\n   * Intended to be overridden\n   * @param {SparkHttpError} reason\n   * @returns {Promise<undefined>}\n   */\n  handleHttpError(reason) {\n    const msg = reason.message || reason.body || reason;\n    return Promise.all(reason.options.body.map((item) => this.getDeferredForRequest(item)\n      .then((defer) => {\n        defer.reject(msg);\n      })));\n  },\n\n  /**\n   * Determines if the item succeeded or failed and delegates accordingly\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  acceptItem(item) {\n    return this.didItemFail(item)\n      .then((didFail) => {\n        if (didFail) {\n          return this.handleItemFailure(item);\n        }\n        return this.handleItemSuccess(item);\n      });\n  },\n\n  /**\n   * Indicates if the specified response item implies a success or a failure\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<Boolean>}\n   */\n   // eslint-disable-next-line no-unused-vars\n  didItemFail(item) {\n    return Promise.resolve(false);\n  },\n\n  /**\n   * Finds the Defer for the specified item and rejects its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemFailure(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.reject(item);\n      });\n  },\n\n  /**\n   * Finds the Defer for the specified item and resolves its promise\n   * Intended to be overridden\n   * @param {Object} item\n   * @returns {Promise<undefined>}\n   */\n  handleItemSuccess(item) {\n    return this.getDeferredForResponse(item)\n      .then((defer) => {\n        defer.resolve(item);\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified request item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForRequest(item) {\n    return this.fingerprintRequest(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error(`Could not find pending request for received response`);\n        }\n        return defer;\n      });\n  },\n\n  /**\n   * Returns the Deferred for the specified response item\n   * @param {Object} item\n   * @returns {Promise<Defer>}\n   */\n  getDeferredForResponse(item) {\n    return this.fingerprintResponse(item)\n      .then((idx) => {\n        const defer = this.deferreds.get(idx);\n        /* istanbul ignore if */\n        if (!defer) {\n          throw new Error(`Could not find pending request for received response`);\n        }\n        return defer;\n      });\n  },\n\n  /**\n   * Generates a unique identifier for the item in a request payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n   // eslint-disable-next-line no-unused-vars\n  fingerprintRequest(item) {\n    throw new Error(`fingerprintRequest() must be implemented`);\n  },\n\n  /**\n   * Generates a unique identifier for the item in a response payload\n   * Intended to be overridden\n   * Note that overrides must return a primitive.\n   * @param {Object} item\n   * @returns {Promise<primitive>}\n   */\n   // eslint-disable-next-line no-unused-vars\n  fingerprintResponse(item) {\n    throw new Error(`fingerprintResponse() must be implemented`);\n  }\n});\n\nexport default Batcher;\n"]}