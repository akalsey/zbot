{"version":3,"sources":["../../../src/lib/storage/make-spark-plugin-store.js"],"names":["makeSparkPluginStorage","defers","type","context","SparkPluginStorage","keyFactory","key","set","spark","del","getNamespace","args","defer","get","then","res","resolve","put","logger","info","promise","initValue","value","parent","catch","reason","process","env","NODE_ENV","toString","includes","reject"],"mappings":"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","file":"make-spark-plugin-store.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\nimport {Defer, oneFlight} from '@ciscospark/common';\nimport {NotFoundError} from './errors';\nimport {result} from 'lodash';\n\nconst defers = new WeakMap();\n\n/**\n * [makeSparkPluginStorage description]\n * @param {[type]} type\n * @param {[type]} context\n * @returns {[type]}\n */\nexport default function makeSparkPluginStorage(type, context) {\n  /**\n   * Interface between SparkPlugin and Spark#boundeStorage or\n   * Spark#unboundedStorage\n   */\n  class SparkPluginStorage {\n    /**\n     * @param {Object} attrs\n     * @param {Object} options\n     * @returns {SparkPluginStorage}\n     */\n    constructor() {\n      defers.set(this, new Map());\n    }\n\n    /**\n     * Clears an entire namespace\n     * @returns {Promise}\n     */\n    clear() {\n      return context.spark[`${type}Storage`].del(context.getNamespace());\n    }\n\n    /**\n     * Deletes the specified key from the store\n     * @param {string} key\n     * @returns {[type]}\n     */\n    del(...args) {\n      return context.spark[`${type}Storage`].del(context.getNamespace(), ...args);\n    }\n\n    /**\n     * Retrieves the value specified by key from the store. Rejects with\n     * NotFoundError if no value can be found\n     * @param {string} key\n     * @returns {Promise}\n     */\n    get(key) {\n      let defer = defers.get(this).get(key);\n      if (!defer) {\n        defer = new Defer();\n        defers.get(this).set(key, defer);\n      }\n\n      return context.spark[`${type}Storage`].get(context.getNamespace(), key)\n        .then((res) => {\n          defer.resolve();\n          return res;\n        });\n    }\n\n    /**\n     * Writes a value to the store\n     * @param {string} key\n     * @param {any} value\n     * @returns {Promise}\n     */\n    put(...args) {\n      return context.spark[`${type}Storage`].put(context.getNamespace(), ...args);\n    }\n\n    /**\n     * Returns a Promise that won't resolve until the value specified by key has\n     * been attempted to be loaded from the store. This allows us to lazily\n     * prevent certain method from executing until the specified keys have been\n     * retrieved from the store.\n     * @param {string} key\n     * @returns {Promise}\n     */\n    waitFor(key) {\n      context.logger.info(`plugin-storage(${context.getNamespace()}): waiting to init key \\`${key}\\``);\n      const defer = defers.get(this).get(key);\n      if (defer) {\n        context.logger.info(`plugin-storage(${context.getNamespace()}): already inited \\`${key}\\``);\n        return defer.promise;\n      }\n\n      context.logger.info(`plugin-storage(${context.getNamespace()}): initing \\`${key}\\``);\n      return this.initValue(key);\n    }\n\n    /**\n     * Attempts to load the specified key from the store and set it on the parent\n     * object.\n     * @param {string} key\n     * @returns {Promise} Resolves (but not with the retrieved value) when\n     * the value retrieval complete\n     */\n    @oneFlight({keyFactory: (key) => `initValue-${key}`})\n    // suppress doc warning because decorators confuse eslint\n    // eslint-disable-next-line require-jsdoc\n    initValue(key) {\n      const defer = new Defer();\n      defers.get(this).set(key, defer);\n\n      // Intentionally bypasses this.get so we don't resolve the promise until\n      // after the parent value is set.\n      context.spark[`${type}Storage`].get(context.getNamespace(), key)\n        .then((value) => {\n          context.logger.info(`plugin-storage(${context.getNamespace()}): got \\`${key}\\` for first time`);\n          if (key === `@`) {\n            context.parent.set(value);\n          }\n          else if (result(context[key], `isState`)) {\n            context[key].set(value);\n          }\n          else {\n            context.set(key, value);\n          }\n          context.logger.info(`plugin-storage(${context.getNamespace()}): set \\`${key}\\` for first time`);\n          defer.resolve();\n          context.logger.info(`plugin-storage(${context.getNamespace()}): inited \\`${key}\\``);\n        })\n        .catch((reason) => {\n          // The  next conditional is a bit of an unfortunate solution to deal\n          // with circular dependencies in unit tests. It should not effect\n          // integration tests or production code.\n          if (reason instanceof NotFoundError || process.env.NODE_ENV !== `production` && reason.toString().includes(`MockNotFoundError`)) {\n            context.logger.info(`plugin-storage(${context.getNamespace()}): no data for \\`${key}\\`, continuing`);\n            return defer.resolve();\n          }\n          context.logger.info(`plugin-storage(${context.getNamespace()}): failed to init \\`${key}\\``, reason);\n          return defer.reject(reason);\n        });\n\n      return defer.promise;\n    }\n  }\n\n  return new SparkPluginStorage();\n}\n"]}