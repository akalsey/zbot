{"version":3,"sources":["../../../src/lib/storage/decorators.js"],"names":["persist","waitForValue","args","length","key","persistDecorator","target","prop","descriptor","TypeError","value","persistExecutor","fn","initializeArgs","ret","changeEvent","on","boundedStorage","put","prepareInitialize","M","S","BlockingKeyMap","blockingKeys","Error","waitForValueDecorator","add","waitForValueExecutor","keys","get","all","map","k","waitFor","then","prototype","inited","identifyTarget","namespace","stack","id","has","initialize","applyInit","init","self","getNamespace","spark","set","logger","info","parent","toLowerCase","handle","reason","process","env","NODE_ENV","toString","includes","resolve","error","reject","promises","forEach","push","catch","delete","size","emit"],"mappings":"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","file":"decorators.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n * @private\n */\n\n/* eslint no-invalid-this: [0] */\n\nimport {\n  curry,\n  debounce,\n  identity,\n  result,\n  wrap\n} from 'lodash';\nimport {NotFoundError} from './errors';\nimport {make} from '@ciscospark/common';\n\n/**\n * Stores the result of fn before returning it\n * @param  {string}   key\n * @returns {Promise} resolves with the result of fn\n */\nexport function persist(...args) {\n  if (args.length === 3) {\n    return persist(`@`)(...args);\n  }\n\n  const [key] = args;\n\n  return function persistDecorator(target, prop, descriptor) {\n    if (prop !== `initialize`) {\n      // Once we have class-based alternative to AmpersandState, it should be\n      // detected here.\n      throw new TypeError(`@persist can only currently be applied to AmpersandState objects or their derivatives and must be applied to the initialize method`);\n    }\n\n    descriptor.value = wrap(descriptor.value, function persistExecutor(fn, ...initializeArgs) {\n      // eslint-disable-next-line no-invalid-this\n      const ret = Reflect.apply(fn, this, initializeArgs);\n      const changeEvent = key === `@` ? `change` : `change:${key}`;\n\n      // Some scenarios will lead to lots of change events on a single tick; we\n      // really only care about writing once things have stopped changing. with\n      // a debounce of zero, we're effectively coalescing all the changes\n      // triggered by a single call to set() and commiting them on the next tick\n      // eslint-disable-next-line no-invalid-this\n      this.on(changeEvent, debounce(() => {\n        if (key === `@`) {\n          // eslint-disable-next-line no-invalid-this\n          return this.boundedStorage.put(key, this);\n        }\n\n        // eslint-disable-next-line no-invalid-this\n        return this.boundedStorage.put(key, this[key]);\n      }, 0));\n      return ret;\n    });\n\n    prepareInitialize(target, prop);\n  };\n}\n\nconst M = Map;\nconst S = Set;\nconst BlockingKeyMap = make(M, M, S);\nconst blockingKeys = new BlockingKeyMap();\n\n/**\n * Prevents fn from executing until key has been (attempted to be) loaded\n * @param {string} key\n * @param {Function} fn\n * @returns {Promise} result of fn\n */\nexport function waitForValue(key) {\n  if (!key) {\n    throw new Error(`\\`key\\` is required`);\n  }\n\n  return function waitForValueDecorator(target, prop, descriptor) {\n    blockingKeys.add(target, prop, key);\n    descriptor.value = wrap(descriptor.value, function waitForValueExecutor(fn, ...args) {\n      const keys = blockingKeys.get(target, prop);\n      return Promise.all([...keys].map((k) => this.boundedStorage.waitFor(k)))\n        .then(() => Reflect.apply(fn, this, args));\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === `object` && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    prepareInitialize(target, prop);\n\n    return descriptor;\n  };\n}\n\n\nconst inited = new Set();\n\n/**\n * finds a means of identitying the `target` param passed to\n * `prepareInitialize()`. When possible, avoids duplicate `init()` calls if\n * namespaces collide\n *\n * @param {Object|Constructor} target\n * @private\n * @returns {String|Constructor}\n */\nfunction identifyTarget(target) {\n  if (target.namespace) {\n    return target.namespace;\n  }\n\n  return target;\n}\n\nconst stack = new Set();\n\n/**\n * @param {Function} target\n * @param {string} prop\n * @returns {undefined}\n */\nfunction prepareInitialize(target, prop) {\n  const id = identifyTarget(target);\n  if (!inited.has(id)) {\n    inited.add(id);\n    if (target.initialize) {\n      target.initialize = wrap(target.initialize, function applyInit(fn, ...args) {\n        const ret = Reflect.apply(fn, this, args);\n        Reflect.apply(init, this, args);\n        return ret;\n      });\n      return;\n    }\n\n    target.initialize = init;\n  }\n\n  /**\n   * @returns {undefined}\n   */\n  function init() {\n    const self = this;\n    const namespace = this.getNamespace();\n    this.spark.initialize = wrap(this.spark.initialize || identity, function applyInit(fn, ...args) {\n      // Call spark's initalize method first\n      // Reminder: in order for MockSpark to accept initial storage data, the\n      // wrapped initialize() must be invoked before attempting to load data.\n      // Reminder: context here is `spark`, not `self`.\n      stack.add(namespace);\n      Reflect.apply(fn, this, args);\n\n      // Then prepare a function for setting values retrieved from storage\n      const set = curry((key, value) => {\n        this.logger.info(`storage:(${namespace}): got \\`${key}\\` for first time`);\n        if (key === `@`) {\n          self.parent.set({\n            [namespace.toLowerCase()]: value\n          });\n        }\n        else if (result(self[key], `isState`)) {\n          self[key].set(value);\n        }\n        else {\n          self.set(key, value);\n        }\n        this.logger.info(`storage:(${namespace}): set \\`${key}\\` for first time`);\n      });\n\n      // And prepare an error handler for when those keys can't be found\n      const handle = curry((key, reason) => {\n        if (reason instanceof NotFoundError || process.env.NODE_ENV !== `production` && reason.toString().includes(`MockNotFoundError`)) {\n          this.logger.info(`storage(${namespace}): no data for \\`${key}\\`, continuing`);\n          return Promise.resolve();\n        }\n        this.logger.error(`storage(${namespace}): failed to init \\`${key}\\``, reason);\n        return Promise.reject(reason);\n      });\n\n      // Iterate over the list of keys marked as blocking via `@waitForValue`\n      const keys = blockingKeys.get(target, prop);\n      const promises = [];\n      keys.forEach((key) => {\n        promises.push(this.boundedStorage.get(namespace, key)\n        .then(set(key))\n        .catch(handle(key)));\n      });\n\n      Promise.all(promises)\n        .then(() => {\n          stack.delete(namespace);\n          if (stack.size === 0) {\n            this.emit(`loaded`);\n          }\n        });\n    });\n  }\n}\n"]}