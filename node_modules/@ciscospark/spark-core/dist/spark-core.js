'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.children = undefined;

var _getOwnPropertyDescriptor = require('babel-runtime/core-js/object/get-own-property-descriptor');

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

var _deleteProperty = require('babel-runtime/core-js/reflect/delete-property');

var _deleteProperty2 = _interopRequireDefault(_deleteProperty);

var _omit = require('lodash/omit');

var _omit2 = _interopRequireDefault(_omit);

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _get = require('lodash/get');

var _get2 = _interopRequireDefault(_get);

var _apply = require('babel-runtime/core-js/reflect/apply');

var _apply2 = _interopRequireDefault(_apply);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _merge = require('lodash/merge');

var _merge2 = _interopRequireDefault(_merge);

var _last = require('lodash/last');

var _last2 = _interopRequireDefault(_last);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _desc, _value, _obj; /**!
                          *
                          * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.
                          * @private
                          */

exports.default = ProxySpark;
exports.registerPlugin = registerPlugin;

var _common = require('@ciscospark/common');

var _httpCore = require('@ciscospark/http-core');

var _ampersandState = require('ampersand-state');

var _ampersandState2 = _interopRequireDefault(_ampersandState);

var _networkTiming = require('./interceptors/network-timing');

var _networkTiming2 = _interopRequireDefault(_networkTiming);

var _payloadTransformer = require('./interceptors/payload-transformer');

var _payloadTransformer2 = _interopRequireDefault(_payloadTransformer);

var _redirect = require('./interceptors/redirect');

var _redirect2 = _interopRequireDefault(_redirect);

var _requestLogger = require('./interceptors/request-logger');

var _requestLogger2 = _interopRequireDefault(_requestLogger);

var _requestTiming = require('./interceptors/request-timing');

var _requestTiming2 = _interopRequireDefault(_requestTiming);

var _responseLogger = require('./interceptors/response-logger');

var _responseLogger2 = _interopRequireDefault(_responseLogger);

var _sparkHttpError = require('./lib/spark-http-error');

var _sparkHttpError2 = _interopRequireDefault(_sparkHttpError);

var _sparkTrackingId = require('./interceptors/spark-tracking-id');

var _sparkTrackingId2 = _interopRequireDefault(_sparkTrackingId);

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _storage = require('./lib/storage');

var _uuid = require('uuid');

var _uuid2 = _interopRequireDefault(_uuid);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object['ke' + 'ys'](descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object['define' + 'Property'](target, property, desc);
    desc = null;
  }

  return desc;
}

var constructorCalled = false;
var derived = {};
var children = exports.children = {};

var Spark = void 0;

var interceptors = {
  SparkTrackingIdInterceptor: _sparkTrackingId2.default.create,
  /* eslint no-extra-parens: [0] */
  RequestLoggerInterceptor: process.env.ENABLE_NETWORK_LOGGING || process.env.ENABLE_VERBOSE_NETWORK_LOGGING ? _requestLogger2.default.create : undefined,
  ResponseLoggerInterceptor: process.env.ENABLE_NETWORK_LOGGING || process.env.ENABLE_VERBOSE_NETWORK_LOGGING ? _responseLogger2.default.create : undefined,
  RequestTimingInterceptor: _requestTiming2.default.create,
  UrlInterceptor: undefined,
  AuthInterceptor: undefined,
  PayloadTransformerInterceptor: _payloadTransformer2.default.create,
  ConversationInterceptor: undefined,
  RedirectInterceptor: _redirect2.default.create,
  HttpStatusInterceptor: function HttpStatusInterceptor() {
    return _httpCore.HttpStatusInterceptor.create({
      error: _sparkHttpError2.default
    });
  },

  NetworkTimingInterceptor: _networkTiming2.default.create
};

var preInterceptors = ['ResponseLoggerInterceptor', 'RequestTimingInterceptor', 'SparkTrackingIdInterceptor'];

var postInterceptors = ['HttpStatusInterceptor', 'NetworkTimingInterceptor', 'RequestLoggerInterceptor'];

var SparkCore = _ampersandState2.default.extend((_obj = {
  derived: {
    boundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkStore)('bounded', this);
      }
    },
    unboundedStorage: {
      deps: [],
      fn: function fn() {
        return (0, _storage.makeSparkStore)('unbounded', this);
      }
    }
  },

  session: {
    config: {
      type: 'object'
    },
    request: {
      setOnce: true,
      // It's supposed to be a function, but that's not a type defined in
      // Ampersand
      type: 'any'
    },
    sessionId: {
      setOnce: true,
      type: 'string'
    }
  },

  authenticate: function authenticate() {
    var _credentials;

    return (_credentials = this.credentials).authenticate.apply(_credentials, arguments);
  },
  authorize: function authorize() {
    var _credentials2;

    return (_credentials2 = this.credentials).authorize.apply(_credentials2, arguments);
  },
  refresh: function refresh() {
    var _credentials3;

    return (_credentials3 = this.credentials).refresh.apply(_credentials3, arguments);
  },


  /**
   * Applies the directionally appropriate transforms to the specified object
   * @param {string} direction
   * @param {Object} object
   * @returns {Promise}
   */
  transform: function transform(direction, object) {
    var _this = this;

    var predicates = this.config.payloadTransformer.predicates.filter(function (p) {
      return !p.direction || p.direction === direction;
    });
    var ctx = {
      spark: this
    };
    return _promise2.default.all(predicates.map(function (p) {
      return p.test(ctx, object).then(function (shouldTransform) {
        if (!shouldTransform) {
          return undefined;
        }
        return p.extract(object)
        // eslint-disable-next-line max-nested-callbacks
        .then(function (target) {
          return {
            name: p.name,
            target: target
          };
        });
      });
    })).then(function (data) {
      return data.filter(function (d) {
        return Boolean(d);
      })
      // eslint-disable-next-line max-nested-callbacks
      .reduce(function (promise, _ref) {
        var name = _ref.name,
            target = _ref.target,
            alias = _ref.alias;
        return promise.then(function () {
          if (alias) {
            return _this.applyNamedTransform(direction, alias, target);
          }
          return _this.applyNamedTransform(direction, name, target);
        });
      }, _promise2.default.resolve());
    }).then(function () {
      return object;
    });
  },


  /**
   * Applies the directionally appropriate transform to the specified parameters
   * @param {string} direction
   * @param {Object} ctx
   * @param {string} name
   * @returns {Promise}
   */
  applyNamedTransform: function applyNamedTransform(direction, ctx, name) {
    for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      rest[_key - 3] = arguments[_key];
    }

    var _this2 = this;

    if ((0, _isString2.default)(ctx)) {
      rest.unshift(name);
      name = ctx;
      ctx = {
        spark: this,
        transform: function transform() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return _this2.applyNamedTransform.apply(_this2, [direction, ctx].concat(args));
        }
      };
    }

    var transforms = ctx.spark.config.payloadTransformer.transforms.filter(function (tx) {
      return tx.name === name && (!tx.direction || tx.direction === direction);
    });
    // too many implicit returns on the same line is difficult to interpret
    // eslint-disable-next-line arrow-body-style
    return transforms.reduce(function (promise, tx) {
      return promise.then(function () {
        if (tx.alias) {
          var _ctx;

          return (_ctx = ctx).transform.apply(_ctx, [tx.alias].concat(rest));
        }
        return _promise2.default.resolve(tx.fn.apply(tx, [ctx].concat(rest)));
      });
    }, _promise2.default.resolve()).then(function () {
      return (0, _last2.default)(rest);
    });
  },
  initialize: function initialize() {
    var _this3 = this;

    this.config = (0, _merge2.default)({}, _config2.default, this.config);

    // Make nested events propagate in a consistent manner
    (0, _keys2.default)(children).forEach(function (key) {
      _this3.listenTo(_this3[key], 'change', function () {
        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        args.unshift('change:' + key);
        _this3.trigger.apply(_this3, args);
      });
    });

    var addInterceptor = function addInterceptor(ints, key) {
      var interceptor = interceptors[key];

      if (!(0, _isFunction2.default)(interceptor)) {
        return ints;
      }

      ints.push((0, _apply2.default)(interceptor, _this3, []));

      return ints;
    };

    var ints = [];
    ints = preInterceptors.reduce(addInterceptor, ints);
    ints = (0, _keys2.default)(interceptors).filter(function (key) {
      return !(preInterceptors.includes(key) || postInterceptors.includes(key));
    }).reduce(addInterceptor, ints);
    ints = postInterceptors.reduce(addInterceptor, ints);

    this.request = (0, _httpCore.defaults)({
      json: true,
      interceptors: ints
    });

    var sessionId = (0, _get2.default)(this, 'config.trackingIdPrefix', 'spark-js-sdk') + '_' + (0, _get2.default)(this, 'config.trackingIdBase', _uuid2.default.v4());
    if ((0, _has2.default)(this, 'config.trackingIdPrefix')) {
      sessionId += '_' + (0, _get2.default)(this, 'config.trackingIdPrefix');
    }

    this.sessionId = sessionId;
  },
  logout: function logout() {
    var _credentials4;

    return (_credentials4 = this.credentials).logout.apply(_credentials4, arguments);
  },


  /**
   * General purpose wrapper to submit metrics via the metrics plugin (if the
   * metrics plugin is installed)
   * @returns {Promise}
   */
  measure: function measure() {
    if (this.metrics) {
      var _metrics;

      return (_metrics = this.metrics).sendUnstructured.apply(_metrics, arguments);
    }

    return _promise2.default.resolve();
  },
  upload: function upload(options) {
    var _this4 = this;

    if (!options.file) {
      return _promise2.default.reject(new Error('`options.file` is required'));
    }

    options.phases = options.phases || {};
    options.phases.initialize = options.phases.initialize || {};
    options.phases.upload = options.phases.upload || {};
    options.phases.finalize = options.phases.finalize || {};

    (0, _defaults2.default)(options.phases.initialize, {
      method: 'POST'
    }, (0, _omit2.default)(options, 'file', 'phases'));

    (0, _defaults2.default)(options.phases.upload, {
      method: 'PUT',
      json: false,
      withCredentials: false,
      body: options.file,
      headers: {
        'x-trans-id': _uuid2.default.v4(),
        authorization: undefined
      }
    });

    (0, _defaults2.default)(options.phases.finalize, {
      method: 'POST'
    }, (0, _omit2.default)(options, 'file', 'phases'));

    var shunt = new _events.EventEmitter();

    var promise = this._uploadPhaseInitialize(options).then(function () {
      var p = _this4._uploadPhaseUpload(options);
      (0, _common.transferEvents)('progress', p, shunt);
      return p;
    }).then(function () {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this4._uploadPhaseFinalize.apply(_this4, [options].concat(args));
    }).then(function (res) {
      return res.body;
    });

    (0, _common.proxyEvents)(shunt, promise);

    return promise;
  },


  _uploadPhaseInitialize: function _uploadPhaseInitialize(options) {
    var _this5 = this;

    this.logger.debug('client: initiating upload session');

    return this.request(options.phases.initialize).then(function () {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this5._uploadApplySession.apply(_this5, [options].concat(args));
    }).then(function (res) {
      _this5.logger.debug('client: initiated upload session');
      return res;
    });
  },

  _uploadApplySession: function _uploadApplySession(options, res) {
    var session = res.body;
    ['upload', 'finalize'].reduce(function (opts, key) {
      opts[key] = (0, _keys2.default)(opts[key]).reduce(function (phaseOptions, phaseKey) {
        if (phaseKey.startsWith('$')) {
          phaseOptions[phaseKey.substr(1)] = phaseOptions[phaseKey](session);
          (0, _deleteProperty2.default)(phaseOptions, phaseKey);
        }

        return phaseOptions;
      }, opts[key]);

      return opts;
    }, options.phases);
  },
  _uploadPhaseUpload: function _uploadPhaseUpload(options) {
    var _this6 = this;

    this.logger.debug('client: uploading file');

    var promise = this.request(options.phases.upload).then(function (res) {
      _this6.logger.debug('client: uploaded file');
      return res;
    });

    (0, _common.proxyEvents)(options.phases.upload.upload, promise);

    /* istanbul ignore else */
    if (process.env.NODE_ENV === 'test') {
      promise.on('progress', function (event) {
        _this6.logger.log('upload progress', event.loaded, event.total);
      });
    }

    return promise;
  },


  _uploadPhaseFinalize: function _uploadPhaseFinalize(options) {
    var _this7 = this;

    this.logger.debug('client: finalizing upload session');

    return this.request(options.phases.finalize).then(function (res) {
      _this7.logger.debug('client: finalized upload session');
      return res;
    });
  }
}, (_applyDecoratedDescriptor(_obj, '_uploadPhaseUpload', [_common.retry], (0, _getOwnPropertyDescriptor2.default)(_obj, '_uploadPhaseUpload'), _obj)), _obj));

/**
 * @returns {undefined}
 */
function makeSparkConstructor() {
  Spark = SparkCore.extend({
    children: children,
    derived: derived
  });
}

/**
 * @param {Object} attrs
 * @param {Object} attrs.credentials
 * @param {Object} attrs.config
 * @returns {Spark}
 */
function ProxySpark() {
  if (!Spark) {
    makeSparkConstructor();
  }

  constructorCalled = true;

  for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  var spark = new (Function.prototype.bind.apply(Spark, [null].concat(args)))();
  return spark;
}

/**
 * @method registerPlugin
 * @param {string} name
 * @param {function} constructor
 * @param {Object} options
 * @param {Array<string>} options.proxies
 * @param {Object} options.interceptors
 * @returns {null}
 */
function registerPlugin(name, constructor, options) {
  /* eslint complexity: [0] */
  if (constructorCalled) {
    var message = 'registerPlugin() should not be called after instantiating a Spark instance';
    // eslint-disable-next-line no-console
    console.warn(message);
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      throw new Error(message);
    }
  }

  options = options || {};

  if (!children[name] || options.replace) {
    children[name] = constructor;

    if (options.proxies) {
      options.proxies.forEach(function (key) {
        derived[key] = {
          deps: [name + '.' + key],
          fn: function fn() {
            return this[name][key];
          }
        };
      });
    }

    if (options.interceptors) {
      (0, _keys2.default)(options.interceptors).forEach(function (key) {
        interceptors[key] = options.interceptors[key];
      });
    }

    if (options.config) {
      (0, _merge2.default)(_config2.default, options.config);
    }

    if ((0, _has2.default)(options, 'payloadTransformer.predicates')) {
      _config2.default.payloadTransformer.predicates = _config2.default.payloadTransformer.predicates.concat((0, _get2.default)(options, 'payloadTransformer.predicates'));
    }

    if ((0, _has2.default)(options, 'payloadTransformer.transforms')) {
      _config2.default.payloadTransformer.transforms = _config2.default.payloadTransformer.transforms.concat((0, _get2.default)(options, 'payloadTransformer.transforms'));
    }

    makeSparkConstructor();
  }
}
//# sourceMappingURL=spark-core.js.map
