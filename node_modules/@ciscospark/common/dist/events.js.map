{"version":3,"sources":["../src/events.js"],"names":["proxyEvents","transferEvents","emitter","proxy","forEach","key","events","source","drain","event","on","args","emit","target","method","trigger","Error","rest"],"mappings":";;;;;;;;;;;;;;QAagBA,W,GAAAA,W;QAqBAC,c,GAAAA,c;;;;AA3BhB;;;;;;AAMO,SAASD,WAAT,CAAqBE,OAArB,EAA8BC,KAA9B,EAAqC;AAC1C,iBAGEC,OAHF,CAGU,UAACC,GAAD,EAAS;AACjBF,UAAME,GAAN,IAAa,YAAa;AACxBH,cAAQG,GAAR;AACA,aAAOF,KAAP;AACD,KAHD;AAID,GARD;;AAUA,SAAOD,OAAP;AACD;;AAED;;;;;;;AA3BA;;;;;AAkCO,SAASD,cAAT,CAAwBK,MAAxB,EAAgCC,MAAhC,EAAwCC,KAAxC,EAA+C;AACpDF,WAAS,uBAAQA,MAAR,IAAkBA,MAAlB,GAA2B,CAACA,MAAD,CAApC;AACAA,SAAOF,OAAP,CAAe,UAACK,KAAD,EAAW;AACxBF,WAAOG,EAAP,CAAUD,KAAV,EAAiB;AAAA,wCAAIE,IAAJ;AAAIA,YAAJ;AAAA;;AAAA,aAAaC,uBAAKJ,KAAL,EAAYC,KAAZ,SAAsBE,IAAtB,EAAb;AAAA,KAAjB;AACD,GAFD;AAGD;;AAED;;;;;AAKA,SAASC,IAAT,CAAcC,MAAd,EAA+B;AAC7B,MAAMC,SAASD,OAAOE,OAAP,IAAkBF,OAAOD,IAAxC;AACA;AACA,MAAI,CAACE,MAAL,EAAa;AACX,UAAM,IAAIE,KAAJ,mCAAN;AACD;;AAL4B,qCAANC,IAAM;AAANA,QAAM;AAAA;;AAO7B,SAAO,qBAAcH,MAAd,EAAsBD,MAAtB,EAA8BI,IAA9B,CAAP;AACD","file":"events.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {isArray} from 'lodash';\n\n/**\n * Proxies the event binding methods of emitter onto proxy\n * @param {EventEmitter|EventEmitterProxy} emitter\n * @param {mixed} proxy (probably a promise)\n * @returns {EventEmitter} Returns the source emitter to ease use in promise chains\n */\nexport function proxyEvents(emitter, proxy) {\n  [\n    `on`,\n    `once`\n  ].forEach((key) => {\n    proxy[key] = (...args) => {\n      emitter[key](...args);\n      return proxy;\n    };\n  });\n\n  return emitter;\n}\n\n/**\n * Given a list of events, fires them on drain when they're emitted from source\n * @param {Array|string} events\n * @param {EventEmitter} source\n * @param {EventEmitter} drain\n * @returns {undefined}\n */\nexport function transferEvents(events, source, drain) {\n  events = isArray(events) ? events : [events];\n  events.forEach((event) => {\n    source.on(event, (...args) => emit(drain, event, ...args));\n  });\n}\n\n/**\n * Emits an event\n * @param {EventEmitter} target The EventEmitter from which to emit an event\n * @returns {mixed}\n */\nfunction emit(target, ...rest) {\n  const method = target.trigger || target.emit;\n  /* istanbul ignore if */\n  if (!method) {\n    throw new Error(`count not determine emit method`);\n  }\n\n  return Reflect.apply(method, target, rest);\n}\n"]}