{"version":3,"sources":["../src/retry.js"],"names":["retry","options","backoff","delay","maxAttempts","strategyOptions","initialDelay","maxDelay","retryDecorator","target","prop","descriptor","value","retryExecutor","fn","args","emitter","promise","resolve","reject","call","cb","innerPromise","on","emit","bind","then","res","catch","reason","Error","err","setStrategy","ExponentialStrategy","failAfter","start","key","callback","prototype"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAuBwBA,K;;AAjBxB;;AACA;;;;;;AAEA;;AAEA;;;;;;;;;;;;AAYe,SAASA,KAAT,CAAeC,OAAf,EAAwB;AACrCA,YAAU,sBAAc,EAAd,EAAkBA,OAAlB,CAAV;AACA,0BAASA,OAAT,EAAkB;AAChBC,aAAS,IADO;AAEhBC,WAAO,CAFS;AAGhBC,iBAAa;AAHG,GAAlB;;AAMA,MAAIC,wBAAJ;AACA,MAAIJ,QAAQC,OAAZ,EAAqB;AACnBG,sBAAkB;AAChBC,oBAAcL,QAAQE,KADN;AAEhBI,gBAAUN,QAAQM;AAFF,KAAlB;AAID,GALD,MAMK;AACHF,sBAAkB;AAChBC,oBAAc,CADE;AAEhBC,gBAAU;AAFM,KAAlB;AAID;;AAED,SAAO,SAASC,cAAT,CAAwBC,MAAxB,EAAgCC,IAAhC,EAAsCC,UAAtC,EAAkD;AACvDA,eAAWC,KAAX,GAAmB,oBAAKD,WAAWC,KAAhB,EAAuB,SAASC,aAAT,CAAuBC,EAAvB,EAAoC;AAAA;;AAAA,wCAANC,IAAM;AAANA,YAAM;AAAA;;AAC5E,UAAMC,UAAU,0BAAhB;AACA,UAAMC,UAAU,sBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/C;AACA;AACA;AACA,YAAMC,OAAO,kBAAQA,IAAR,CACX,UAACC,EAAD,EAAQ;AACN;AACA,cAAMC,eAAe,qBAAcR,EAAd,SAAwBC,IAAxB,CAArB;;AAEA,cAAI,0BAAWO,aAAaC,EAAxB,CAAJ,EAAiC;AAC/BD,yBAAaC,EAAb,aAA4BP,QAAQQ,IAAR,CAAaC,IAAb,CAAkBT,OAAlB,aAA5B;AACAM,yBAAaC,EAAb,oBAAmCP,QAAQQ,IAAR,CAAaC,IAAb,CAAkBT,OAAlB,oBAAnC;AACAM,yBAAaC,EAAb,sBAAqCP,QAAQQ,IAAR,CAAaC,IAAb,CAAkBT,OAAlB,sBAArC;AACD;;AAED,iBAAOM,aACJI,IADI,CACC,UAACC,GAAD,EAAS;AACbN,eAAG,IAAH,EAASM,GAAT;AACD,WAHI,EAIJC,KAJI,CAIE,UAACC,MAAD,EAAY;AACjB,gBAAI,CAACA,MAAL,EAAa;AACXA,uBAAS,IAAIC,KAAJ,6DAAT;AACD;AACDT,eAAGQ,MAAH;AACD,WATI,CAAP;AAUD,SArBU,EAsBX,UAACE,GAAD,EAAMJ,GAAN,EAAc;AACZ,cAAII,GAAJ,EAAS;AACP,mBAAOZ,OAAOY,GAAP,CAAP;AACD;;AAED,iBAAOb,QAAQS,GAAR,CAAP;AACD,SA5BU,CAAb;;AA+BAP,aAAKY,WAAL,CAAiB,IAAI,kBAAQC,mBAAZ,CAAgC5B,eAAhC,CAAjB;AACA,YAAIJ,QAAQG,WAAZ,EAAyB;AACvBgB,eAAKc,SAAL,CAAejC,QAAQG,WAAR,GAAsB,CAArC;AACD;;AAEDgB,aAAKe,KAAL;AACD,OAzCe,CAAhB;;AA2CAlB,cAAQM,EAAR,GAAa,SAASA,EAAT,CAAYa,GAAZ,EAAiBC,QAAjB,EAA2B;AACtCrB,gBAAQO,EAAR,CAAWa,GAAX,EAAgBC,QAAhB;AACA,eAAOpB,OAAP;AACD,OAHD;;AAKA,aAAOA,OAAP;AACD,KAnDkB,CAAnB;;AAqDA;AACA;AACA,QAAI,OAAOR,MAAP,iBAA8B,CAACA,OAAO6B,SAA1C,EAAqD;AACnD7B,aAAOC,IAAP,IAAeC,WAAWC,KAA1B;AACD;;AAED,WAAOD,UAAP;AACD,GA7DD;AA8DD,C,CA3GD","file":"retry.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport {defaults, isFunction, wrap} from 'lodash';\nimport {EventEmitter} from 'events';\nimport backoff from 'backoff';\n\n/* eslint max-nested-callbacks: [0] */\n\n/**\n * Makes a promise-returning method retryable according to the specified backoff\n * pattern\n * @param {Object} options\n * @param {boolean} options.backoff\n * @param {number} options.delay\n * @param {number} options.initialDelay\n * @param {number} options.maxAttempts\n * @param {number} options.maxDelay\n *\n * @returns {Function}\n */\nexport default function retry(options) {\n  options = Object.assign({}, options);\n  defaults(options, {\n    backoff: true,\n    delay: 1,\n    maxAttempts: 3\n  });\n\n  let strategyOptions;\n  if (options.backoff) {\n    strategyOptions = {\n      initialDelay: options.delay,\n      maxDelay: options.maxDelay\n    };\n  }\n  else {\n    strategyOptions = {\n      initialDelay: 1,\n      maxDelay: 1\n    };\n  }\n\n  return function retryDecorator(target, prop, descriptor) {\n    descriptor.value = wrap(descriptor.value, function retryExecutor(fn, ...args) {\n      const emitter = new EventEmitter();\n      const promise = new Promise((resolve, reject) => {\n        // backoff.call is not Function.prototype.call; it's an unfortunate naming\n        // collision.\n        /* eslint prefer-reflect: [0] */\n        const call = backoff.call(\n          (cb) => {\n            /* eslint no-invalid-this: [0] */\n            const innerPromise = Reflect.apply(fn, this, args);\n\n            if (isFunction(innerPromise.on)) {\n              innerPromise.on(`progress`, emitter.emit.bind(emitter, `progress`));\n              innerPromise.on(`upload-progress`, emitter.emit.bind(emitter, `upload-progress`));\n              innerPromise.on(`download-progress`, emitter.emit.bind(emitter, `download-progress`));\n            }\n\n            return innerPromise\n              .then((res) => {\n                cb(null, res);\n              })\n              .catch((reason) => {\n                if (!reason) {\n                  reason = new Error(`retryable method failed without providing an error object`);\n                }\n                cb(reason);\n              });\n          },\n          (err, res) => {\n            if (err) {\n              return reject(err);\n            }\n\n            return resolve(res);\n          }\n        );\n\n        call.setStrategy(new backoff.ExponentialStrategy(strategyOptions));\n        if (options.maxAttempts) {\n          call.failAfter(options.maxAttempts - 1);\n        }\n\n        call.start();\n      });\n\n      promise.on = function on(key, callback) {\n        emitter.on(key, callback);\n        return promise;\n      };\n\n      return promise;\n    });\n\n    // This *should* make decorators compatible with AmpersandState class\n    // definitions\n    if (typeof target === `object` && !target.prototype) {\n      target[prop] = descriptor.value;\n    }\n\n    return descriptor;\n  };\n}\n"]}