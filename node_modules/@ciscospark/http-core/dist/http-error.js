'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _pick = require('lodash/pick');

var _pick2 = _interopRequireDefault(_pick);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extendError = require('extend-error');

var _extendError2 = _interopRequireDefault(_extendError);

var _httpErrorSubtypes = require('./http-error-subtypes');

var _httpErrorSubtypes2 = _interopRequireDefault(_httpErrorSubtypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class HttpError
 * @extends Error
 */
/**!
 *
 * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.
 */

var HttpError = (0, _extendError2.default)({
  parseFn: function parseFn(res) {
    /* eslint complexity: [0] */
    var body = res.body;
    var message = void 0;
    switch (typeof body === 'undefined' ? 'undefined' : (0, _typeof3.default)(body)) {
      case 'string':
        try {
          body = JSON.parse(body);
          message = parseObject(body);
        } catch (error) {
          message = body;
        }
        break;
      case 'object':
        message = parseObject(body);
        break;
      default:
      // do nothing
    }

    if (!message) {
      message = this.defaultMessage;
    }

    (0, _defineProperties2.default)(this, {
      body: {
        enumerable: false,
        value: body
      },
      httpVersion: {
        enumerable: false,
        value: res.httpVersion
      },
      headers: {
        enumerable: false,
        value: res.headers || {}
      },
      rawHeaders: {
        enumerable: false,
        value: res.rawHeaders || []
      },
      trailers: {
        enumerable: false,
        value: res.trailers || {}
      },
      rawTrailers: {
        enumerable: false,
        value: res.rawTrailers || []
      },
      method: {
        enumerable: false,
        value: res.method
      },
      url: {
        enumerable: false,
        value: res.url
      },
      statusCode: {
        enumerable: false,
        value: res.statusCode
      },
      statusMessage: {
        enumerable: false,
        value: res.statusMessage
      },
      socket: {
        enumerable: false,
        value: res.socket
      },
      _res: {
        enumerable: false,
        value: res
      }
    });

    return message;
  },
  properties: {
    defaultMessage: 'An error was received while trying to fulfill the request'
  },
  subTypeName: 'HttpError'
});

/**
 * @param {object} body
 * @private
 * @returns {string}
 */
function parseObject(body) {
  // Search body for common names of error strings
  var messages = (0, _values2.default)((0, _pick2.default)(body, 'message', 'error', 'errorString', 'response', 'errorResponse', 'msg'));

  // If no error candidate was found, stringify the entire body
  if (messages.length === 0) {
    return (0, _stringify2.default)(body, null, 2);
  }

  // Assume the first key found was the error explanation
  var message = messages[0];

  // If the explanation is an object, recurse and try again
  if (typeof message === 'object') {
    return parseObject(message);
  }

  // Return the first key
  return message;
}

(0, _httpErrorSubtypes2.default)(HttpError);
HttpError.makeSubTypes = _httpErrorSubtypes2.default;

exports.default = HttpError;
//# sourceMappingURL=http-error.js.map
