{"version":3,"sources":["../../src/request/request.js"],"names":["_request","prepareOptions","options","responseType","encoding","withCredentials","jar","Buffer","isBuffer","body","then","type","headers","resolve","doRequest","logger","r","error","response","warn","statusCode","method","url","on","total","parseInt","loaded","data","length","download","emit"],"mappings":";;;;;;;;;;kBAkGwBA,Q;;AA7FxB;;;;AACA;;;;AACA;;;;;;AAEA;;;;;AAKA,SAASC,cAAT,CAAwBC,OAAxB,EAAiC;AAC/B,MAAIA,QAAQC,YAAR,iBAAqCD,QAAQC,YAAR,WAAzC,EAA0E;AACxED,YAAQE,QAAR,GAAmB,IAAnB;AACD;;AAED,MAAIF,QAAQG,eAAZ,EAA6B;AAC3BH,YAAQI,GAAR,GAAc,IAAd;AACD;;AAED,MAAIC,OAAOC,QAAP,CAAgBN,QAAQO,IAAxB,CAAJ,EAAmC;AACjC,WAAO,sBAAOP,QAAQO,IAAf,EACJC,IADI,CACC,UAACC,IAAD,EAAU;AACdT,cAAQU,OAAR,mBAAkCD,IAAlC;AACA,aAAOT,OAAP;AACD,KAJI,CAAP;AAKD;;AAED,SAAO,kBAAQW,OAAR,CAAgBX,OAAhB,CAAP;AACD;;AAED;;;;;AAlCA;;;;;AAuCA,SAASY,SAAT,CAAmBZ,OAAnB,EAA4B;AAC1B,SAAO,sBAAY,UAACW,OAAD,EAAa;AAC9B,QAAME,SAASb,QAAQa,MAAvB;;AAEA,QAAMC,IAAI,uBAAQd,OAAR,EAAiB,UAACe,KAAD,EAAQC,QAAR,EAAqB;AAC9C,UAAID,KAAJ,EAAW;AACTF,eAAOI,IAAP,CAAYF,KAAZ;AACD;;AAED,UAAIC,QAAJ,EAAc;AACZA,iBAAShB,OAAT,GAAmBA,OAAnB;;AAEA;AACA;AACA,YAAIA,QAAQC,YAAR,iBAAqCe,SAAST,IAAT,CAAcE,IAAd,aAArC,IAAwE,CAACJ,OAAOC,QAAP,CAAgBU,SAAST,IAAzB,CAA7E,EAA6G;AAC3GS,mBAAST,IAAT,GAAgB,IAAIF,MAAJ,CAAWW,SAAST,IAApB,CAAhB;AACD;;AAED,YAAIF,OAAOC,QAAP,CAAgBU,SAAST,IAAzB,KAAkC,CAACS,SAAST,IAAT,CAAcE,IAArD,EAA2D;AACzDE,kBAAQ,sBAAOK,SAAST,IAAhB,EACLC,IADK,CACA,UAACC,IAAD,EAAU;AACdO,qBAAST,IAAT,CAAcE,IAAd,GAAqBA,IAArB;AACA,mBAAOO,QAAP;AACD,WAJK,CAAR;;AAMA;AACD;;AAEDL,gBAAQK,QAAR;AACD,OApBD,MAqBK;AACH;AACAL,gBAAQ;AACNO,sBAAY,CADN;AAENlB,0BAFM;AAGNU,mBAASV,QAAQU,OAHX;AAINS,kBAAQnB,QAAQmB,MAJV;AAKNC,eAAKpB,QAAQoB,GALP;AAMNb,gBAAMQ;AANA,SAAR;AAQD;AACF,KArCS,CAAV;;AAuCAD,MAAEO,EAAF,aAAiB,UAACL,QAAD,EAAc;AAC7B,UAAMM,QAAQC,SAASP,SAASN,OAAT,kBAAT,EAA6C,EAA7C,CAAd;AACA,UAAIc,SAAS,CAAb;AACAR,eAASK,EAAT,SAAoB,UAACI,IAAD,EAAU;AAC5BD,kBAAUC,KAAKC,MAAf;AACA1B,gBAAQ2B,QAAR,CAAiBC,IAAjB,aAAkC,4BAAkBJ,MAAlB,EAA0BF,KAA1B,CAAlC;AACD,OAHD;AAID,KAPD;AAQD,GAlDM,CAAP;AAmDD;;AAED;;;;;AAKe,SAASxB,QAAT,CAAkBE,OAAlB,EAA2B;AACxC,SAAOD,eAAeC,OAAf,EACJQ,IADI,CACCI,SADD,CAAP;AAED","file":"request.js","sourcesContent":["/**!\n *\n * Copyright (c) 2015-2016 Cisco Systems, Inc. See LICENSE file.\n */\n\nimport detect from '../lib/detect';\nimport ProgressEvent from '../progress-event';\nimport request from 'request';\n\n/**\n * @param {Object} options\n * @private\n * @returns {Promise}\n */\nfunction prepareOptions(options) {\n  if (options.responseType === `buffer` || options.responseType === `blob`) {\n    options.encoding = null;\n  }\n\n  if (options.withCredentials) {\n    options.jar = true;\n  }\n\n  if (Buffer.isBuffer(options.body)) {\n    return detect(options.body)\n      .then((type) => {\n        options.headers[`content-type`] = type;\n        return options;\n      });\n  }\n\n  return Promise.resolve(options);\n}\n\n/**\n * @param {Object} options\n * @private\n * @returns {Promise}\n */\nfunction doRequest(options) {\n  return new Promise((resolve) => {\n    const logger = options.logger;\n\n    const r = request(options, (error, response) => {\n      if (error) {\n        logger.warn(error);\n      }\n\n      if (response) {\n        response.options = options;\n\n        // I'm not sure why this line is necessary. request seems to be creating\n        // buffers that aren't Buffers.\n        if (options.responseType === `buffer` && response.body.type === `Buffer` && !Buffer.isBuffer(response.body)) {\n          response.body = new Buffer(response.body);\n        }\n\n        if (Buffer.isBuffer(response.body) && !response.body.type) {\n          resolve(detect(response.body)\n            .then((type) => {\n              response.body.type = type;\n              return response;\n            }));\n\n          return;\n        }\n\n        resolve(response);\n      }\n      else {\n        // Make a network error behave like a browser network error.\n        resolve({\n          statusCode: 0,\n          options,\n          headers: options.headers,\n          method: options.method,\n          url: options.url,\n          body: error\n        });\n      }\n    });\n\n    r.on(`response`, (response) => {\n      const total = parseInt(response.headers[`content-length`], 10);\n      let loaded = 0;\n      response.on(`data`, (data) => {\n        loaded += data.length;\n        options.download.emit(`progress`, new ProgressEvent(loaded, total));\n      });\n    });\n  });\n}\n\n/**\n * @name request\n * @param {Object} options\n * @returns {Promise}\n */\nexport default function _request(options) {\n  return prepareOptions(options)\n    .then(doRequest);\n}\n"]}